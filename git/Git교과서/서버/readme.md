## 5.1 서버 저장소

서버 저장소는 다른 말로 원격 저장소라고 한다. 서버 저장소는 로컬 저장소의 코드를 복제한 복사본이라고 할 수 있다. 서버를 이용하면 코드를 안전하게 보관할 수 있다. 또 서버에 있는 소스코드는 다른사람들과 공유하고 협업하여 개발을 진행할 수있다.

### 5.1.1 협업 저장소

분산형 모델

### 5.1.2 연속된 작업

원격 저장소가 있다면 언제 어디에서든지 개발을 이어서 할 수 있다. 사무실에서 개발중인 코드를 서버에 저장하고 집에와서는 사무실에서 작업하고 서버에 올린 코드를 자신의 컴퓨터에 동기화할 수 있다. 깃은 분산된 저장소 여러개를 하나로 통합하고 최신 코드를 배포할 수 있다. 서버 저장소는 여러 컴퓨터에 동일한 깃 저장소를 복제하고 작업한 결과물을 서버로 통합한다.

### 5.1.3 새 멤버

기존에는 코드를 공유하려고 이메일등을 사용했지만 이제는 깃의 원격 저장소주소만 알려주면 모두 해결된다. 

### 5.3.2 프로토콜 

서버와 통신하려면 프로토콜을 사용해야한다. 깃은 서버와 통신할 수 있는 다양한 프로토콜을 지원한다. 깃은 기본적으로 Local, HTTP, SSH, Git 네 종류의 전송 방식을 지원한다. 

1. local 

로컬 컴퓨터에 원격 저장소를 생성하는 것을 의미한다. 이방식은 자신의 컴퓨터를 NFS등 서버로 이용할 때 편리하다. 로컬 저장소를 서버로 이용할 때는 폴더 경로만 입력하면된다.
로컬은 간단하게 원격 서버를 구축할 수 있을 뿐만아니라 빠른 동작이 가능하다. 하지만 모든 자료가 자신의 컴퓨터에 집중되는 위험도 있다.

2. HTTP
3. SSH
4. Git

### 5.3.3 원격 저장소의 리모트 목록관리

깃은 원격저장소를 관리하는데 remote 명령어를 사용한다. remote 명령어를 사용하면 현재 연결된 원격 저장소 목록을 확인할 수 있다. remote 명령어에는 다양한 옵션이 있으며 -help옵션으로 확인할 수 있다. 명령어 하나로 다수의 리모트 작업을 하기 때문에 몇가지 옵션은 반드시 알고 넘어가야한다. 
`git remove -v`

-v옵션을 같이 사용하면 원격 저장소의 별칭 이름과 URL을 확인할 수 있다. 깃은 복수의 저장소를 연결하여 사용할 수 있다. 리모트 저장소가 여러개 있을 때는 목록을 모두 출력한다. 하지만 저장소의 권한 정보까지는 알 수 없다. 

### 5.3.4 주소와 별칭

별칭: 원격 서버의 주소는 긴 문자열로 되어있다. 매번 원격 서버에서 작업할 때마다 긴 문자열을 입력하는 것은 피곤하다. 간략하게 긴서버 url문자열을 별칭으로 만들어 사용할 수있다.

원격저장소가 연결되면 fetch 와  push 두조소를 출력한다. push는 서버로 전송하는 동작을 의미하고, fetch 는 반대로 서버에서 가지고 오는 동작을 의미한다.


원격 저장소를 등록하면 원격 브랜치가 자동 생성된다. 로컬과 서버 저장소를 구분한다.

서로 동기화한 시점 판별.


### 5.3.7 별칭 이름 변경과 정보

별칭은 긴 문자열 서버 주소를 대체한다.등록된 서버의 별칭이름은 다시 변경할 수 있다.

`git remote rename 변경전 변경후`

### 5.3.8 원격 서버 삭제

로컬 저장소는 복수의 원격 저장소와 연결할 수 있다.
깃을 사용하다 보면 풀 리퀘스트 테스트등 목적으로 임시 등록된 원격 저장소들도 있다. 등록된 원격 저장소는rm 옵션으로 삭제할 수 있다.

`git remote rm 원격저장소별칭`

## 5.4 서버 전송

푸시는 원격 저장소로 커밋된 파일들을 업로드하는 동작이다. 

자신의 로컬 저장소를 백업하는 용도로 원격저장소를 사용할 수 있다. 꼭 다른 사람들과 협업하려고 깃의 원격 저장소를 사용하는 것은 아니다. 

## 5.5 자동으로 내려받기

복제할 때는 clone 명령어를 사용한다. 


#### 5.5.2 pull

복제는 원격 저장소에서 모든 내용을 한번에 내려받는다. 복제후 원격 저장소의 갱신된 내용을 추가로 내려받으려면 pull명령어를 사용한다.

pull명령어는 로컬 저장소보다 최신인 갱신된 원격 저장소의 커밋 정보를 현재 로컬 저장소로 내려받는다. pull 명령어를 주기적으로 사용하면 최신 커밋 정보로 로컬 저장소를 유지할 수 있다.

## 5.6 수동으로 내려받기

원격 저장소 내용을 내려받는 방법은 크게 두가지이다. pull과 fetch이다. 이 두가지 방법의 차이는 병합을 자동 처리하는지 여부이다. 

### 5.6.1 자동 병합

풀은 원격 서버에서 현재 커밋보다 최신커밋 정보가 있을 때 내려받는다. 내려받은 커밋 정보는 임시 영역에 저장한다. 스테이지 영역이 아닌 원격 저장소를 위한 전용 임시 브랜치가 따로있다.

내려받은 최신 커밋들을 현재 브랜치로 자동 병합처리한다. 여기서 병합은 원격서버 파일과 로컬서버파일을 하나로 합치는 과정이다. 혼자서 개발하는 프로젝트는 pull 명령어만으로도 편리하게 사용할 수 있다.

하지만 여러개발자와 협업으로 코드를 작성할 때 pull명령어를 사용한 자동병합은 가끔 문제가 생긴다. 여러 개발자와 협업하는 과정에서 pull명령어가 자동으로 브랜치 병합을 하지 못하고 충돌이 발생하기도한다. 
이처럼 pull명령어로 자동병합을 하지 못할 때에는 페치 방식을 사용한다.

### 5.6.2 fetch 가져오기

페치는 원격저장소에서 코드를 수동으로 내려받는 작업을 한다. 페치는 원격저장소에서 커밋된 코드를 임시 브랜치로 내려받는다. 내려받은 후 현재 브랜치와 자동 병합하지않는다.

`git fetch 원격저장소URL`

페치는 원격저장소의 커밋들만 가지고 왔을 뿐 로컬 저장소에서 어떤 작업도 하지않는다.

### 5.6.3 merge 명령으로 수동병합

페치는 데이터를 내려받기만할 뿐 자동병합하지 않는다. 내려받은 커밋을 로컬 저장소에 적용하려면 병합명령을 실행해야하는데,  merge명령어를 사용한다. 

`git merge 원격저장소별칭/브랜치이름`




## 5.7 순서

### 5.7.1최신상태

먼저 원격 저장소에 푸시하려면 자신의 로컬 저장소를 최신 상태로 유지해야한다. 즉 자신의 저장소가 원격 저장소보다 최신이어야한다는 의미이다. 최신이라는 의미를 좀더 구체적으로 알아보자.

누군가 내 저장소보다 먼저 커밋하여 새로운 커밋으로 서버를 갱신했다. 하지만 나는 간발의 차이로 갱신된 서버 정보를 가지고 있지 않다. 푸시는 서버의마지막 커밋과 푸시되는 커밋을 병합한다. 
이 때 내 커밋은 서버의 최신 커밋보다 늦은 커밋으로 밀리게된다. 커밋이 순차적이지 않을 때 깃은 푸시 동작을 거부한다.

### 5.7.2 충돌방지

깃이 최신 상태에서만 푸시를 허용하는 것은 충돌을 방지하기 위해서이다. 원격 저장소의 커밋을 내려받는 풀 작업은 내려받은 커밋들을 현재 브랜치로 자동 병합한다. 

풀과 푸시를 자주하여 충돌을 최소한으로 줄여 나가면서 작업을 유지한다. 소스트리를 사용하면 푸시하기 전에 자신의 저장소와 어떤 차이점이 있는지 쉽게 확인할 수 있다. 소스트리의 push위에 조그마한 숫자가 표시된다. 숫자는 현재 로컬저장소와 원격 저장소간 커밋 차이점을 출력한다.

