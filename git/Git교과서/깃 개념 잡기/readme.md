## 3.1 깃 저장소 생성

깃은 작성된 소스코드 파일의 모든 변경 사항을 관리한다. 그렇다면 깃은 파일의 변경 내역을 어떻게 저장하고 관리할 수 있을까? 깃은 이러한 변경사항을 전용 저장소에 저장한다.
이 저장소는 일반적으로 사용하는 폴더와 유사하지만, 조금 차이가있다. 깃의 동작 방식을 이해하려면 저장소 동작 원리를 확실히 알아야한다. 


### 3.1.1 폴더와 깃 저장소

깃 저장소는 외형적으로 폴더와 유사하다. 사용자 입장에서는 일반 폴더와 깃 저장소를 구별없이 모두 동일하게 사용할 수 있다.

깃 저장소에는 별도의 숨겨진 영역이 있는데, 여기에 버전 관리 시스템에 필요한파일 변경 이력을 기록한다. 저장소는 프로젝트의 모든 리비전과 히스토리를 가진 데이터베이스와 같다.

즉 일반적인 폴더와 깃 저장소의 차이점은 숨겨진 영역이 있는지 여부이다.


### 3.1.2 초기화

깃에서 초기화란 이미 존재하는 폴더에 초기화 명령어로 vcs관리를 위한 숨겨진 영역을 생성하는 작업을 의미한다.

이제 터미널에서 초기화 명령어를 입력한다.깃 명령어는 보통 git 키워드와 명령어를 함께 입력한다.

`git init 경로명`

git init 명령어는 기존 폴더에 숨겨진 영역을 추가한다. 숨겨진 영역을 추가함으로써 깃 저장소로 변경되는 것이다.

초기화 명령어를 입력할 때 경로명을 입력하지 않으면 현재 폴더에서 초기화 된다. 
git init 명령어는 기본적으로 로컬 저장소를 생성하며 다양한 옵션을 추가로 제공한다.

### 3.1.3 숨겨진 폴더 = .git 폴더

깃 저장소를 초기화한다는 것은 별도의 숨겨진 폴더를 하나 추가하고 환경 설정 파일을 생성하는 것이다. .git 폴더에는 깃 저장소에 필요한 모든 뼈대 파일이 담겨 있다. 이러한 뼈대 파일들은 깃 초기화를 통하여 자동 생성된다.

깃의 숨겨진 폴더 .git 은 매우 중요하다 이 폴더에는 깃으로 관리되는 모든 파일 및 브랜치 등 이력을 기록한다. 따라서 컴퓨터에서 깃 저장소를 통째로 복사하고자 할 때는 숨겨진 .git 폴더까지 같이 복사해야한다. .git 폴더를 삭제하거나 함께 복사하지 않으면 깃의 모든 이력은 없어진다. 즉 일반적인 폴더 파일과 동일하다.

숨겨진 폴더까지 복사하려면 일반적인 cp로는 안되고 -r옵션을 사용해야 숨겨진 폴더도 함께 복사된다.

`cp -r 원본폴더 복사폴더`


## 3.2 워킹 디렉터리

깃의 동작을 이해하려면 먼저 워킹 디렉터리 개념을 알아야한다. 워킹 디렉터리는 다른 용어로 워킹 트리라고도한다.

### 3.2.2 파일의 untracked , tracked 상태
깃의 추적 개념을 알아보자. 깃이 다른 vcs보다 뛰어난 것은 지정된 파일들의 모든 것을 추적하는 관리 시스템이기 때문이다. 깃은 워킹 디렉터리에 있는 파일들을 추적됨과 추적되지 않음 상태로 구분한다.

워킹 디렉터리에 새로 생성된 파일은 모두 추적되지 않음 상태이다. 이 파일으로관리하려면 깃에 추적하라고 통지해 주어야한다.
통지하지 않은 파일은 깃에서 따로 추적하지 않는다.

워킹 디렉터리에 새 파일을 추가하면 추적되지 않음 상태이다. 워킹 디렉터리 안에 추적되지 않은 상태의 파일들은 별도로 명령어를 실행하여 추적상태로 변경해주어야한다. 이때느 git add 명령어를 사용한다.

깃이라고 모든 파일을 자동으로 완벽하게 관리할 수는 없다. 수많은 파일을 모두 자동으로 처리해야한다면 시스템에 엄청난 부하가 발생한다.
깃은 요청받은 파일들만 추적관리한다. 사실 깃 입장에서는 어떤 파일이 정말로 추적관리가 필요한지 알 수 없다. 따라서 추적하는 파일들은 tracked 상태로 표시한다. track 와 untracked 개념을 사용하는 것은 시스템 부하를 줄이고 좀더 효율적으로 파일이력을 관리하기 위해서이다. 개발자에게 관리할 파일 목록들을 제출해 달라고 요청하는 것이 더 현명하다. 따라서 요청받은 파일들만 이력을 관리한다면 매번 파일 목록을 추적하려고 많은 리소스를 낭비할 필요가 없다. 

이렇게 관리할 파일 목록에 등록된 상태를 추적상태라고한다.

## 3.3 스테이지
깃은 여러 단계의 논리적인 저장공간을 가지고있다. 스테이지는 임시로 저장하는 공간을 의미한다. 스테이지 영역은 워킹 디렉터리에서 제출된 tracked 된 파일들을 관리한다. 

### 3.3.1 스테이지 == 임시영역
스테이지는 워킹 디렉터리와 실제로 저장하여 기록하는 공간 사이에있는 임시 영역이다. 깃은 워킹 디렉터리에서 작업이 끝난 파일을 스테이지로 잠시 복사한다.스테이지가 임시 영역이라고해서 파일의 콘텐츠 내용을 직접 가지고 있지는 않다. 단지 커밋하려는 파일의 추적상태 정보들만 기록한다.


이처럼 임시 영역인 스테이지를 별도로 운영하는 것은 커밋을 빠르게 처리하기 위해서이다. 실제로 저장하여 기록하는 공간인 저장소는 스테이지 영역에서 가리키는 파일 내용을 기반으로 변경된 차이점만 기록한다.

파일들의 스테이지 상태는 status 명령어로 확인 가능하다. 또한 깃의 git ls-files 같은 명령어로도 확인 가능하다.

`git status , git ls-files --stage`

### 3.2.2 stage state unstage state

워킹 디렉터리에 있는 tracked 상태의 파일들은 스테이지 영역과 긴밀한 관계를 맺는다. 
스테이지 영역은 파일을 stage 상태와 unstage 상태로 구분한다. 깃이 변화이력을 기록하려면 파일들의 최종 상태가 stage 상태이어야한다. unstage 상태라면 파일에 변화가 있다는 것을 의미한다. 즉 스테이지 영역에 있는 파일과 워킹 디렉터리 안에 있는 파일 내용에 차이가 있을 때는 unstage 상태가된다.

### 3.3.3 modified state unmodified state

코드를 변경한다는 것은 워킹 디렉터리에서 파일을 수정하는 것을 의미한다. 

파일이 수정되면 워킹 디렉터리와 스테이지간 내용이 일치하지 않는다. 따라서 스테이지는 수정한 파일과 원본파일을 구분하려고 수정함상태와 수정하지 않은 상태로 표현한다. 파일 수정 작업은 스테이지 영역과 긴밀한 상관관계를 맺는다.

파일 수정은 개발과정에서 뗄수없는 작업이다. 개발작업에서 수많은 코드가 변경되고, 깃을 사용하면 이 변경 내역은 영구적으로 기록된다.

깃은 수정 여부만 체크를 해주기 때문에  modified 상태로 변경된 파일은 스테이지로 재등록해야한다. 수정된 파일을 스테이지 영역으로 다시 적용하려면  git add 명령어로 재등록해야한다.

> unmodified 상태

tracked 상태이면서 스테이지에서 한번도 수정을 하지 않은 원본상태를 의미한다. 이처럼 수정하지 않은 파일들을 재등록하지 않아도 된다. 스테이지에 등록한후 어떤 수정도 하지 않았다면 unmodified 상태이다. 깃은 파일의 수정 여부를 체크하고 스테이지 영역의 갱신 작업 여부를 작업자에게 알려준다.


정리하면 다음과 같다. git add 로 스테이지에 올리고 이때 자동으로 tracked 상태가 된다. 파일을 수정하지 않으면 계속 stage 상태에 머무른다. 파일이 수정되면 modified 상태가 되고, 스테이지에서 떨어져 나와 unstage 상태가된다. unstage 상태의 파일은 워킹 디렉터리에 잠시 담아둔다. 이때 다시 등록 명령을 실행하며 stage 상태로 변경된다.


## 3.4 파일의 상태 확인
상태 개념은 깃의 분리된 저장 영역인 워킹 디렉터리와 스테이지 추적여부를 의미한다. 깃이 이렇게 다양한 저장영역을 구분해서 가지고 있는 것은 파일들의 상태를 효율적으로 모니터링하기 위해서이다. 이번에는 파일들의 상태를 모니터링 할 수 있는 status 명령어를 알아보자.

## 3.5 파일 관리 목록에서 제외 .gitignore

깃은 tracked 상태인 모든 것을 추적 관리한다.

파일뿐만 아니라 서브 폴더와 그 안의 파일들도 포함한다. 즉 디렉터리 전체가 모두 관리 대상이다.

깃으로 관리하고 싶지 않은 파일과 폴더는 별도의 .gitignore 설정 파일 안에 나열해서 적어준다.

### 3.5.1 .gitignore 

.이있어서 숨겨진 파일로 관리된다.
이파일은 깃에서 관리하지 않는 파일들의 목록을 지니고 있다. 깃은 이 파일에 작성된 목록들을 추적하지 않는다.

또 로컬 저장소를 서버로 전송하거나 다른사람과 공유할 때도 이를 분리하여 처리한다.

이파일은 저장소 폴더의 최상위 디렉터리에 두어야한다.


### 3.5.2 .gitignore 파일 표기법
파일에서 #으로 시작하는 줄은 주석처리한다.
에스터리스크 기호를 사용하여 패턴을 정의할 수 있다. *기호는 모든 문자열을 대체할 수 있다. 이러한 문자를 셸 글로빙이라고한다. 글로빙 문자를 사요하여 패턴을 확장한다.

ignore 패턴을 작성할 때 반드시 추적관리를 제외하는 파일만 작성하는 것은 아니다. 제외하지 않는 파일과 필요한 파일 이름 앞에 느낌표 !를 사용한다. 느낌표는 부정을 의미하는 not과 같다.

```.gitignore
# 환경 설정 파일은 제외하면 안 됨
!config.php
# 현재 디렉터리 안에있는 파일 무시
/readme.txt
# /pub/ 디렉터리 안에 모든것을 무시
/pub/
# doc 디렉터리 아래의 모든.txt파일 무시
doc/**/*.txt

```

깃은 glob패턴을 지원하기 때문에 정규표현식을응용하여 작성 규칙을 넣을 수 있다.


## 3.6 깃 저장소 복제
외부 저장소를 이용하여 로컬 저장소를 생성하는 것을 깃 저장소 복제라고한다.

### 3.6.1 공개 저장소

깃 호스팅 서비스는 공개된 저장소와 비공개된 저장소를 모두 지원한다. 공개된 저장소는 누구나 복제하여 코드를 내려 받을 수 있다. 

### 3.6.2 다운로드 vs 복제

일반적으로 소스코드를 얻으려면 압축파일을 내려받는다. 소스코드를 내려받는다는 것은 해당 코드의 최종 복사본을 내 컴퓨터에 가져오는 것이다. 하지만 이러한 내려받기는 깃의 이력을 포함한 저장 영역까지 내려받는 것은 아니다. 이와 달리 깃을 이용하여 저장소를 복제하면 최종 코드뿐만 최종 코드뿐만아니라 중간에 커밋과 같으 ㄴ변화의 모든 이력도 같이 내려받을 수 있다. 또 일부 코드를 변경하여 기여하는 것도 가능할 것이다.

### 3.6.3 복제 명령어

깃의 저장소를 복제하는 명령어는 clone 이다.

복제하려면 공개된 저장소의 uul이 필요하다. 복제할 때 폴더이름을 지정하지 않으면 공개된 저장소에서 사용된 폴더와 동일하 ㄴ이름으로 새폴더를 만든다. 다른 이름으로 복제하길 원한다면새 폴더 이름을 추가 인자로 적어준다.

`git clone url 새폴더 이름`

깃은 저장소안에 있는 파일들과 .git 리포지터리를 기반으로 이력을 관리한다. 따라서 복제한 후에는 복제된 폴더의 이름을 그대로 사용하지 않아도 된다. 필요에 따라 깃의 폴더이름을 변경해도 괜찮다.
