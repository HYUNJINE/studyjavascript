## 4.1 코드의 변화

깃은 개발중인 코드의 이력을 만들 수 있다. 깃이 코드 변화를 기록하는 것을 커밋이라고한다.

commit 은 뜻이 여러개인데, 유사한 의미로는 '~를 적어주다' 즉 커밋은 의미있는 변경 작업들을 저장소에 기록하는 동작이다.

일반적으로 새로운 기능을 추가하는 코드를 삽입한다. 또 버그를 수정하려고 많은 코드를 이동하거나 대체하는데 이러한 코드 수정은 개발 목적을 달성하는 작업들이다.

깃은 코드의 변경 이력과 시점을 커밋으로 기록한다.

### 4.1.1 파일 관리 방법

깃이 없던 시절에는 파일을 복사해서 관리했으므로 모든 내용이 중복되고 용량도 많이차지한다. 반면 깃의 커밋은 새로 변경된 부분만 추출하여 저장한다. 그것도 파일 이름을 변경하지 않고도 동일한 파일 이름으로 하나로 관리가 가능하다. 즉 시간에 따라 변화하는 내용만 관리하고, 코드가 변화된시간 순서에 따라서 영구적으로 저장한다. 이를 커밋이라고 한다. 

개발자 입장에서는 복잡한 구조의 파일을 관리하지 않아도 되고 여러개의 파일보다는 파일 하나로 모든 이력을 처리하기 때문에 유용하다. 커밋은 부모 커밋은 부모 커밋을 기반으로 변화된 부분만 새로운 커밋으로 생성한다. 그리고 커밋은 파일의 시간적 변화도 함께 저장한다. 


워킹 디레터리에 새로 추가된 untracked 상태의 파일을 추적 가능 상태로 변경하는 것을 등록이라고 한다. 또 파일을 등로갛면 워킹 디렉터리의 파일이 스테이지 영역에 추가된다.

스테이지 영역의 관리목록에 추가된 파일만 깃에서 이력을 추적할 수 있다.

워킹 디렉터리는 작업을 위한 일종의 샌드박스(서로 분리되어있는 영역)와 같다.

깃에서 등록이란 워킹디렉터리에 있는 파일을 스테이지 영역으로 복사하는 것을 의미한다. 여기서 복사는 실제 파일 복사하는 것을 의미하지는 않는다. 깃 내부에서 논리적인 기록을 변경하는 과정일 뿐이다. 복사라고 표현한 것은 이해하기 쉽게 풀어쓴 것이다. 



워킹 디렉터리에 추가된 모든 파일을 커밋할 때는 반드시 이과정을 거친다. 그래야 깃에 버전 이력을 관리 할 수 있다. 스테이지에 등록되지 않은 unstage 상태의 파일들은 커밋할 수 없다. 

파일 이름 대신 . 을 이용하면 전체 파일과 폴더를 모두 등록할 수 있다. 점은 리눅스와 같은 운영체제에서 현재 디렉터리를 의미하는 기호이다. 

워킹 디렉터리에 생성된 모든 파일을 스테이지 영역에 추가할 필요는 없다 필요한 파일만 스테이지 영역에 등록하여 이력을 추적한다. 스테이지 영역에 등록하지 않은 파일은 커밋작업에 포함되지 않는다.빈 폴더는 스테이지 영역에 등록할 수 없다. 폴더안에 파일이 하나이상 있어야 등록가능하다.


### 4.3.3 파일 등록 취소 

이번에는  tracked 상태를 untracked 상태로 변경해보자. 스테이지에 등록하는 것과 반대 과정이다. unstage 상태로 변경하려면 rm 또는 reset 명령어를 사용한다. 

`git rm --cached index.html`

스테이지의 캐시된 목록에서 파일이 삭제된다. 확인하려면 git status

파일을 등록한 후 커밋하지 않고 바로 삭제하려면 rm --cached 명령어를 사용하낟. 하지만 한번이라도 커밋을 했다면 reset명령어를 새용해야한다. 커밋후에rm 으로 삭제하면 삭제또는 변화된 것으로 간주한다. 따라서 커밋된 파일은 리셋으로 삭제한후 정리해 주어야한다. 




### 4.3.4 등록된 파일 이름이 변경되었을 때

작업도중 파일 이름도 변경할 수 있다. 하지만 별도로 이를 깃에 통보할 필요는 없다.

`git mv 파일이름 새파일이름`

```cmd
mv index.html home.html
git rm index.html
git add home.html
```


이름 변경은 그냥하면 깃이 추적할꺼야.


## 4.4 첫번째 커밋 

### 4.4.1 HEAD

깃에는 HEAD라는 포인터 개념이 있다. HEAD커밋을 가리키는 묵시적 참조 포인터이다.  HEAD는 최종적인 커밋 작업의 위치를 가리킨다. 앞에서 새로운 커밋은 이전 부모 커밋을 기반으로 새로운 커밋을 만든다고 했다. 바로 부모 커밋을 가리킨다. 단 깃을 설치하고 처음 커밋할 때는 HEAD의 포인터가 없다. 최소한 한번 이상 커밋을 해야 HEAD가존재.

HEAD는 커밋이 변화한 최종 시점을 의미한다.

### 4.4.2 스냅샷

커밋은 파일의 변화를 깃 저장소에 영구적으로 기록한다. 이러한 커밋은 이전에 파일을 복사하여 관리하던 방식돠는 큰 차이가 있다. 깃이 다른 버전관리도구와 다른 점은 스냅샷방식을 이용한다는 것이다. 파일을 복사하는 방식으로 수정본을 관리하면 같은 내용을 반복해서 저장하기에 많은 용량을 차지한다. 
또 수정된 부분들을 일일이 찾아야하기 때문에 검색할 때도 매우 불편하다.


깃은 파일에서 변경된 부분을 찾아 수정된 내용만 저장한다. 마치 변화된 부분만 찾아 사진을 찍는 것과 비슷하다고 하여 스냅샷 방식이라고한다.

깃의 스냅샷은 HEAD가 가리키는 커밋을 기반으로 사진을 찍는다. 그리고 이를 스테이지 영역과 비교하여 새로운 커밋으로 기록한다. 이처럼 스냅샷 방식을 이용하여빠르게 버전의 차이점을 처리하고 용량을 적게 사용한다.

### 4.4.3 파일 상태와 커밋 

tracked 상태인 파일을 수정하면 다시 modified 상태로 변경된다. modified는 untracked 상태이다. untracked 상태의 파일은 반드시 등록 명령으로 다시 스테이지 상태로 재등록해야한다. 재등록하면 다시 tracked 상태가 된다.

깃의 커밋은 HEAD와 스테이지 영역 간 차이를 비교하여 새로운 객체를 생성한다. 생성된 객체를 깃 저장소에 기록한다.

커밋은 스냅샷을 이용하여 새로 수정된 파일과 디렉터리를 묶는 트리 객체이다. 커밋을 하면 새로운 트리 객체로 변환하는 것과 유사하다.

> 커밋 메시지

커밋은 변경된 파일차이를 깃 저장소에 기록한다. 따라서 커밋을 할 때 생성된 객체를 기록하는 것과 동시에이를 구별할 수 있는 메시지를 같이 작성해야한다. 변화된 각 커밋 객체에 꼬리표처럼 설명을 달아 놓는다고 생각하면 된다. 이 설명들을 커밋 메시지라고한다. 

복사하는 형태로 백업할 때는 일일이 파일 이름을 수정하여 구분하였다. 하지만 커밋은 파일 이름을 여러개 사용하지 않고 하나만 가진다. 기존처럼 파일이름으로 변화된 객체를 구별할 수 없다.

그 대신 깃은 변화된 객체를 구별하고자 메시지 시스템을 도입하였다. 파일 이름을 사용하지 않고 별도로 작성한 메시지 문자열로 각 변경 객체들을 쉽게 구분할 수 있다. 모든 커밋은 반드시 커밋 메시지를 작성해야한다. 

커밋 메시지를 작성하지 않으면 커밋이 거부된다. 

vi에디터에서 키밋 메시지를 작성할 때는 요약 내용과 상세내용을 분리하여 기록하면 좋다. 첫째 줄에 제목을적고 다음줄에는 상세 내용을 작성하곤한다. 중간에 빈줄로 구분해주는 것도 좋다. 

> 파일 등록과 커밋을 동시에하는법


`git commit -a`

-a옵션은 커밋을 하기전에 자동으로 모든 파일을 등록하는 과정을 미리 수행한다. 따라서 파일 등록과 커밋을 동시에 실행하는 것이다.

## 4.5 커밋확인

### 4.5.1 스테이지 초기화

커밋을 하면 스테이지 영역은 초기화된다. 

더이상 추가된 파일과 수정된 파일이 없다는 것이다.


### 4.5.2 로그 기록확인

커밋한후 커밋 기록은 어떻게 확인할까? 깃은 커밋목록을 확인할 수 있는 log명령어를 별도로 제공한다.

`git log`

log명령어는 시간순서로 커밋 기록을 출력하는데, 최신 커밋기록부터 내림차순으로 나열한다.커밋한후에는 습관적으로 한번씩 깃로그 명령어를 실행하여 기록을 확인하는 습관이 좋다. 또 로그 명령어는 다양한 커밋 기록을 확인 할 수 있도록 여러 옵션을 제공한다 -help옵션으로확인가능하다.

커밋시간을 맹목적으로 믿을수는 없다. 깃은 분산형 저장소로 각자의 pc에 설정한 시간정보를 바탕으로 커밋기록을 작성한다. 작업중인 컴퓨터가 다른지역의 시간이나 잘못된 시간으로 설정되어있을 수도있다.

### 4.6.3 수정된 파일 되돌리기

파일을 수정하면modified 상태로된다. 하지만 수정하는 과정에서 파일을 잘못 수정할 수도있다. 파일을 수정전 상태로 되돌리려면 어떻게 할까?
깃을 이용하면 수정한 파일을 커밋전 마지막 내용으로 쉽게 되돌릴 수 있다. 바로 이전 커밋으로 되돌리는 명령어는 다음과같다.

`git checkout -- 수정파일이름`

수정 파일을 되돌리면 이전 커밋 이후에 작업한 수정 내역은 모두 삭제한다.

변경된 소스코드를 커밋하는 것은 처음 파일을 생성하고 등록하는 과저오가 매우 유사하다.

> -m -a 옵션

`git commit -am "커밋메시지"`

a는 워킹 디렉터리에 있는 파일을 스테이지영역으로 모두 이동한다. -m은 간단한 커밋 메시지를 함께등록한다. 이러한 커밋 옵션들을 같이사용가능하다.

-a옵션은 이미 추적된 파일 상태가 변경되었을 때만 함께 사용이 가능하다. 저장소를 새롭게 생성하고 새 파일을 작성한 후라면 -am으로 커밋할 수 없다.

## 4.7 메시지가 없는 빈 커밋

`git commit --allow-empty-message -m ""`

깃은 마지막 커밋을 수정할 수 있는 --amend 옵션을 제공한다. `git commit --amend`

이 명령어를 실행하면 직전메시지를 에디터 창에 표시한다. 내용을 수정하여 저장하면 변경된 커밋을 확인할 수 있다.





## 4.8 커밋 아이디

각 커밋에는 이상한 영문과 숫자가 있다. 이를 커밋아이디라고 한다. 커밋아이디는 특정 커밋을 가리키는 절대적이름이고 명시적 참조값이다.

커밋아이디는 다수의 커밋을 구분할 수 있는 키이며, 브랜치나 태그 등에도 많이 사용한다. 
이sha1해시키는 앞의 7자리로만으로도 중복을 방지하면서 전체키 값을 사용할 수 있다.

커밋의 상세정보확인하고싶다면

`git show 커밋id`

## 4.10 diff명령어

깃의 장점은 파일들의 수정이력을 커밋이라는 형태로 구분할 수 있다는 점이다. 
깃은 커밋으로 파일들의 수정 내역을 추적한다. 파일 수정이란 파일 내용 일부가 수정 추가 삭제되는 것을 의미한다. 깃은 커밋을 기준으로 이러한 파일들의 수정 이력을 비교해 볼 수 있는 diff기능을 제공한다.
diff 기능으로 파일의 수정 및 변경 내역을 쉽게 파악할 수 있다.

diff 내용을 추가하여 커밋하려면

`git commit -v` 로 커밋하면 diff내용이 추가된다. 


커밋 작업은 깃에서 소스코드를 관리하는 첫 단추이다. 너무 많은 코드를 수정한후 커밋하는 것 보다는 작은 단위로 코드를 수정한 후 커밋하자.

