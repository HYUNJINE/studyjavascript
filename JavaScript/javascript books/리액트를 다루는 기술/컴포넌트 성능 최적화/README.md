# 컴포넌트 성능 최적화

useState 의 기본값에 함수의 이름만 넣어주면 컴포넌트가 처음 렌더링 될 때만 함수가 실행된다. 하지만 함수() 함수를 호출해버리면 리렌더링 될 때마다 useState의 인자인 함수가 호출되어서 매번 실행된다.

컴포넌트 리렌더링 성능을 최적화해주는 작업을 해야한다. 리렌더링이 불필요하다면, 방지해주어야한다.


컴포넌트의 props가 바뀌지 않았다면 리렌더링 하지 않는 React.memo를 사용한다.

useReducer에서 첫번째는 reducer함수를 넣어주고, 두번째는 초기값을 넣는다.하지만 함수를 이용해서 초기값을 생성하고 싶을 때 두번째에다가 undefined를 넣고 세번째에 함수이름만적어준다(호출하면 안됌) 그러면 컴포넌트가 맨처음 렌더링될 때만 함수가 호출된다.

프로덕션 모드 yarn build -> serve -s build

리액트 컴포넌트에서 상태를 업데이트 할때 불변성을 지키는 것은 매우 중요하다. 업데이트가 필요한 곳에서는 아예 새로운 배열 혹은 새로운 객체를 만들기 때문에, React.memo를 사용했을 때 props가 바뀌었는지 혹은 바뀌지 않았는지를 알아내서 리렌더링 성능을 최적화 해줄 수 있다.

이렇게 기존 값을 수정하지 않으면서 새로운 값을 만들어 내는 것을 불변성을 지킨다라고 한다.

불변성이 지켜지지 않으면 객체 내부의 값이 새로워져도 바뀐 것을 감지하지 못한다. 그러면 React.memo에서 서로 비교하여 최적화하는 것이 불가능해진다.

추가로 전개연산자를 사용하여 객체나 배열 내부의 값을 복사할 때는 얕은 복사를 하게된다. 즉 내부의 값이 완전히 새로 복사되는 것이 아니라 가장 바깥쪽에 있는 값만 복사된다. 따라서 내부의 값이 객체혹은 배열이라면 내부의 값또한 따로 복사해주어야한다.

```js
const todos = [{id: 1, checked:true}, {id: 2, checked:false}]


const nextTodos = [...todos];


nextTodos[0].checked = false;


console.log(todos[0] ===nextTodos[0])
// true

nextTodos[0] = {
    ...nextTodos[0]
}

console.log(todos[0] ===nextTodos[0])
// false
```

배열혹은 객체의 구조가 정말 복잡해진다면, 이렇게 불변성을 유지하면서 업데이트하는 것도 까다로워진다. 이렇게 복잡할 경우 immer이라는 라이브러리의 도움을 받으면 정말 편하게 작업할 수 있다.

react-virtualized를 사용하면 리스트 컴포넌트에서 스크롤되기 전에 보이지 않는 컴포넌트는 렌더링하지 않고 크기만 차지하게끔 할 수 있다.
그리고 만약 스크롤되면 해당 스크롤 위치에서 보여주어야 할 컴포넌트를 자연스럽게 렌더링 시킨다. 이라이브러리를 사용하면 낭비되는 자원을 아주 쉽게 아낄수 있다.
