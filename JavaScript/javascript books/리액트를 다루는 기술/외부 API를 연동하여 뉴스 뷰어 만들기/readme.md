웹 애플리케이션을 만들다보면 처리할 때 시간이 걸리는 작업이 있다. 예를 들어 웹 애플리케이션에서 서버쪽 데이터가 필요할 때는 Ajax기법을 사용하여 서버의 API를 호출함으로써 데이터를 수신한다. 이렇게 서버의 API를 사용해야 할 때는 네트워크 송수신 과정에서  시간이 걸리기 때문에 작업이 즉시 처리되는 것이 아니라, 응답을 받을 때까지 기다렸다가 전달받은 응답데이터를 처리한다. 이과정에서 해당 작업을 비동기적으로 처리하게 된다.

비동기적으로 처리한다면 웹 애플리케이션이 멈추지 않기 때문에 동시에 여러가지 요청을 처리할 수도 있고, 기다리는 과정에서 다른 함수도 호출 할 수 있다.


axios 는 현재 가장 많이 사용되고 있는 자바스크립트 HTTP클라이언트이다. 이 라이브러리의 특징은 HTTP요청을 Promise기반으로 처리한다는 점이다.


> useEffect에 등록하는 함수에 async를 붙이면 안된다. useEffect에서 반환해야하는 값은 뒷정리 함수이기 때문이다. async 는 promise를 반환하므로
> 내부에서async 함수를 사용하고 싶다면 함수 내부에 async키워드가 붙은 또다른 함수를 만들어서 사용해 주어야한다.
> 다른 이름의 함수안에서 그 스코프에 promise를 리턴하는것을 받아주는 변수가 필요하다. 최상위 레벨 async는피하자.



white-space 속성에대하여
> normal: 연속 공백을 하나로 합침 개행문자도 다른 공백 문자와 동일하게 처리한다. 한줄이 너무 길어서 넘칠경우 자동으로 줄 바꿈

> nowrap 연속 공백을 하나로 합침 줄바꿈은 br태그에서만일너난다.

> pre 연속 공백 유지.
`<a href={url} target="_blank" rel="noopener noreferrer">` 에 대하여 _blank 연결문서 새창에서 연다.

target _blank 속성을 noopener 을 사용하지 않고 사용한다면 연결중인 페이지는 연결 페이지에 부분적으로 엑세스 할 수 있다. window.opener객체는 연결페이지에서 이전페이지를 제어할 수 있는 권한이 있다는 건데, 최악의 경우 window.opener객체를 활용해서 악의적인 동작을 일으킬수있다. rel 속성으로 noopenner를 사용하면 window.opener객체가 존재하지 않는 것을 확인 할 수 있다.