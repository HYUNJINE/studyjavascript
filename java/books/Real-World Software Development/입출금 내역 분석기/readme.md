## 2.2 목표

한개의 클래스로 문제를 구현해보고 프로젝트를 진행하면서 바뀌는 요구사항이나 유지보수에 대응하며 기존 구조의 한계가 무엇인지 확인한다.


## 2.3 입출금 내역 분석기 요구 사항

- 은행 입출금 내역의 총 수입과 총 지출은 각각 얼마인가? 결과가 양수인가음수인가.
- 특정 달엔 몇건의 입출금 내역이 발생했는가?
- 지출이 가장 높은 상위 10건은 무엇인가?
- 돈을 가장 많이 소비하는 항목은 무엇인가?

## 2.4 KISS 원칙
 keep it short and simple 원칙을 이용해 응용프로그램 코드를 한개의 클래스로 구현한다. 아직은 파일이 존재하지 않거나 파일 내용을 파싱할 때 발생하는 문제를 해결하기 위한 에러처리를 신경쓸 필요는 없다.
 
### 2.4.1 final 변수

이 변수 값은 재할당 불가. 자바언어에서 사용하긴 하지만 final 키워드가 쓸모없는 상황도있다. 바로 추상메서드의 메서드 파라미터에 final 을 사용하는 상황이다. 

## 2.5 코드 유지보수성과 안티패턴

- 특정 기능을 담당하는 코드를 쉽게 찾을 수 있어야한다.
- 코드가 어떤 일을 수행하는지 쉽게 이해할 수 있어야한다.
- 새로운 기능을 쉽게 추가하거나 기존 기능을 쉽게 제거할 수 있어야한다.
- 캡슐화가 잘되어있어야한다. 즉 코드 사용자에게는 세부 구현 내용이 감춰져 있으므로 사용자가 쉽게 코드를 이해하고, 기능을 바꿀수 있어야한다.

궁극적으로 개발자의 목표는 현재 만들고 있는 응용프로그램의 복잡성을 관리하는 것이다. 하지만 새로운 요구사항이 생길 때마다 복사, 붙여넣기로 이를 해결한다면 다음과 같은 문제가 생긴다. 
이는 효과적이지 않은 해결 방법으로 알려져있으며 안티 패턴이라고 부른다.

- 한개의 거대한 갓 클래스 때문에 코드를 이해하기어렵다.
- 코드 중복 때문에 코드가불안정하고 변화에 쉽게망가진다.

### 2.5.1 갓 클래스

### 2.5.2 코드 중복

데이터 형식이 바뀐다면? 

결론적으로 코드를 간결하게 유지하는 것도 중요하지만 KISS 원칙을 남용하지 않아야한다. 전체응용프로그램의 설계를 되돌아보고, 한문제를 작은 개별 문제로 분리해 더 쉽게 관리할 수 있는지 파악해야한다.

이 과정을 통해 더 이해하기 쉽고, 쉽게 유지보수하며, 새로운 요구사항도 쉽게 적용하는 결과물을 만들 수 있다.

## 2.6 단일 책임 원칙

한클래스는 한 기능만 책임진다. 클래스가 바뀌어야하는 이유는 오직 하나여야한다.

## 2.7 응집도
응집도는 코드 구현에서 중요한 ㅌㄱ성이다. 단어 자체가 난해하면서도 멋져보이지만 실제로 응집도는 코드 유지보수성을 결정하는 중요한 개념이다.
응집도는 서로 어떻게 관련되어있는지를 가리킨다. 정확히 말하자면 응집도는 클래스나 메서드의 책임이 서로얼마나 강하게 연결되어ㅣㅇㅆ는지를 측정한다. 즉 어떤것이 여기저기에 모두 속해있는지를 말한다. 응집도는 소ㅍ트트웨어의 복잡성을 유추하는데 도움을 준다. 프로그램의 진입전인 클래스를 살펴보면 이클래스는 파서 , 계산 , 화면으로 결과 전송등 응용프로그램의 다양한 부분을 연결한다는 사실을 알수 있다. 하지만 현재 계산 작업을 하는 로직은 BankStatementAnalyzer 내의 정적 메서드로 선언되어있다 .ㄷ


### 2.7.1 클래스 수준 응집도

정보

같은 데이터나 도메인 객체를 처리하는 메서드를 그룹화하는 방법도 있다. 예를 들어 BankTransaction 객체를 만들고 읽고 갱신하고 삭제하는 기능이 필요해 이런 기능만 제공하는 클래스를 만들어야한다.



데이터 접근 객체(Data access object) 라 부르는 것은 특정 도메인 객체를 저장하는 데이터 베이스와 상호작용할 때 흔히 볼수 있고 객체를 식별하는 일종의 ID가 필요하다. 기본적으로DAO는 영구저장 데이터베이스나 인메모리 데이터베이스 같은 데이터 소스로의 접근을 추상화하고 캡슐화한다.

정보 응집은 여러 기능을 그룹화하면서, 필요한 일부 기능을 포함하는 클래스 전체를 디펜던시로 추가한다는 약점이 있다. 

유틸리티 클래스의 사용은 낮은 응집도로 이어지므로 자제해야한다. 메서드가 서로 연관성이 없으므로 클래스 전체의 기능을 추론하기 어렵다. 더욱이 유틸리티 클래스에서는 특징을 찾기가 어렵다. 쉽게 코드를 찾고 어떻게 사용할 수 있는지 이해하기 쉽도록 만들어야한다. 하지만 유틸리티 클래스는 관련성이 없는 여러 메서드를 명확하지 않은 기준으로 그룹화하므로 이 원칙을 거스른다.

시간 응집 클래스는 여러 연산 중 시간과 관련된 연산을 그룹화한다. 어떤 처리 작업으 ㄹ시작하기 전과 뒤에 초기화 뒷정리 작업을 포함하는 클래스가 그 예다. 초기화 작업은 다른 작업과 관련이 없지만 다른 작업보다 먼저 실행되어야한다.

### 2.7.2 메서드 수준 응집도

응집도 원칙은 클래스뿐만 아니라 메서드에도 적용할 수 있다. 메서드가 다양한 기능을 수행할 수록 메서드가 어떤 동작을 하는지 이해하기가 점점 어려워진다. 즉 메서드가 연관이 없는 여러일을 처리한다면 응집도가 낮아진다. 응집도가 낮은 메서드는 여러책임을 포함하기 때문에 각 책임을 테스트하기 어렵고 메서드의 책임도 테스트하기가 어렵다. 일반적으로 클래스나 메서드 파라미터의 여러 필드를 바꾸는 if /else 블록이 여러개 퐣ㅁ되어있다면, 이는 응집도에 문제가 있음을 의미하므로 응집도가 높은 더 작은 조각으로 메서드를 분리하는 것이 좋다.

## 2.8 결합도

어떤 클래스의 코드를 바꾸면 이 클래스에 의존하는 모든 클래스가 영향을 받는다. 시계를 생각하면 결합도를 쉽게 이해할 수 있다. 시계가 어떻게 동작하는지 몰라도 시간을 알아내는데 문제가없다. 즉 사람은 시계 내부의 구조에 의존하지 않기 때문이다. 따라서 시계내부구조를 바꾸더라도 사람이 시계를 읽는데 영향을 받지 않는다. 이는 두가지 임무인 인터페이스와 구현이 서로 결합되지 않았기 때문이다. 

코드를 구현할 때는 결합도를 낮춰야한다. 이는 코드의 다양한 컴포넌트가 내부와 세부 구현에 의존하지 않아야함을 의미한다. 반대로 높은 결합도는 무조건 피해야한다.

## 2.9 테스트

제이유닛을 활용해서 자동화된 테스트를 구현한다.

### 2.9.1 테스트 자동화

시간이 흐르면서 테스트의 필요성은 명확해진다. 만약 새로운 자도 ㅇ비행 소프트웨어가 실제로 동작하는지를 테스트하지않고 출시한다면 어떻게 되겠는가.

하지만 수동 테스트에만 의존하면 안된다. 자동화된 테스트에서는 사람의 조작없이 여러 테스트가 포함된 스위트가 자동으로 실행된다. 즉 여러분이 코드를 바꿨을 때, 지정된 테스트가 빠르게 실행되므로 소프트웨어가 예상하지 못한 문제를 일으키지 않고 제대로 동작할 것이라는 확신을 조금 더 가질수 있다. 상업용으로 소프트웨어를 개발하는 전문 개발자는 보통 수백 또는 수천개의 자동화된 테스트를 실행한다.

여기서는 좋은 소프트웨어를 개발하는데 테스트가 왜 중요한지 알려주겠다.

- 확신 : 소프트웨어가 규격 사양과 일치하며 동작하는지를 테스트해 고객의 요구사항을 충족하고 있다는 사실을 더욱 확신할 수 있다. 테스트 규격 사양과 결과를 고객에게 증거로 제공할수도 있다. 즉 테스트가 고객의 사양이된다.
- 변화에도 튼튼함 유지 : 코드를 바꿨을 때 소프트웨어의 다른 부분을 실수로 망가뜨리지 않았는지 어떠헥 알수 있을까? 코드가 많지 않으면 문제를 쉽게 해결할 수 있다. 하지만 코드베이스에 수백만 행의 코드가 있다면 얘기가 달라진다. 동료가 코드를 수정했을 때 문제가 발생하지 않을 거라는 것을 어떻게 확신할 수 있을까? 자동화된 테스트 스위트가 있다면 바꾼 코드로 인해 새로운 버그가 발생하지 않았음을 확인하는데 큰 도움이 된다.
- 프로그램 이해도: 테스트 자동화는 소스코드의 프로젝트에서 다양한 컴포넌트가 어떻게 동작하는지 이해하는데 도움을 준다. 테스트는 다양한 컴포넌트의 디펜던시와 이들이 어떻게 상호작용하는지를 명확하게 드러낸다. 따라서 소프트웨어의 전체 개요를 빨리 파악할 수 있다. 

### 2.9.2 제이유닛 활용하기

테스트 메서드 정의하기 

먼저 어디에 테스트 코드를 위치해야하는가..

메이븐과 그레들 빌드도구에서느 src/main/java 에 코드 src/test/java 에 테스트 클래스를 저장하는 것이 기본 규칙이다. 또한 프로젝트에 제이유닛 라이브러리를 디펜던시로 추가해야한다. 3장에서 메이븐과 그레이들로 프로젝트 구성을 배운다.

유닛 테스트 클래스는 그냥 보통 클래스이고 보통 테스트 클래스명에는 Test라는 접미어를 붙이는 것이관습이다.

- 클래스의 메서드는 테스트 메서드의 구현을 보지않고도 무엇을 구현하는지 알수 있도록 서술적인 이름을 붙이는 것이 좋다.
- 비공개 헬퍼메서드를 테스트 클래스에 선언할 수 있지만 테스트러너는 이런 메서드를 실행하지 않는다.


어서션 구문

- Assertions.fail(message) : 메서드 실행결과를 실패로 만들고 테스트 코드를 구현하기전에 플레이스 홀더로 유용하게 활용가능
- Assertions.assertEquals()


### 2.9.3 코드 커버리지

70에서 90 퍼센트의 커버리지를 목표로 정할것을 권한다.

코드 커버리지가 높다고 해서 우리가 소프트웨어를 잘 테스트하고 있음을 의미하는 것은 아니다. 코드 커버리지는 테스트하지 않은 부분이 남아있음을 알려주는 역할에 지나지 않기 때문에 테스트의 품질과는 아무 관련이 없다. 

자바에서는 자코코, 에마, 코베르투라 같은 코드 커버리지 도구를 많이 사용한다. 


## 2.10 총정리

- 갓 클래스와 코드 중복은 코드를 추론하고 유지보수하기 어렵게 만드는 요인이다.
- 단일 책임 원칙은 관리하고 유지보수하기 쉬운 코드를 구현하는데 도움을 준다.
- 응집도는 클래스나 메서드의 책임이 얼마나 강하게 연관되어 있는지를 가리킨다.
- 결합도는 클래스가 다른 부분의 코드에 얼마나 의존하고 있는지를 가리킨다.
- 높은 응집도와 낮은 결합도는 유지보수가 가능한 코드가 가져야할 특징이다.
- 자동화된 테스트 스위트는 소프트웨어가 올바로 동작하며, 코드를 수정해도 잘 동작할 것임을 확신할 수 있고, 프로그램을 쉽게 이해할수 있도록 도움을 준다.
- 자바 테스트 프레임 워크로 유명한 제이유닛을 활용해 메서드와 클래스의 동작을 테스트하는 유닛 테스트를 만든다. 

## 3.2 

개방 폐쇄 원칙을 배워보자. 언제 인터페이스를 사용해야 좋을지를 설명하는 일반적인 가이드라인과 높은 결합도를 피할 수 있는 기법도 배운다. 자바에서 언제 API에 예외를 포함하거나 포함하지 않을 지를 결정하는 자바의 예외 처리 방버도 배운다. 

## 3.3 확장된 입출금 내역 분석기의 요구사항

1. 특정 입출금 내역을 검색할 수 있는 기능, 예를 들어 주어진 날짜 범위 또는 특정 범주의 입출금 내역 얻기
2. 검색 결과의 요약 통계를 텍스트 HTMl등 다양한 형식으로 만들기

## 3.4 개방 폐쇄 원칙

- 거래 내역의 여러 속성을 조합할수록 코드가 점점 복잡해진다.
- 반복로직과 비즈니스 로직이 결합되어 분리하기가 어렵다.
- 코드를 반복한다.

개방/폐쇄 원칙은 이런 상황에 적용한다 코드를 직접 바꾸지 않고 해당 메서드나 클래스으 ㅣ동작을 바꿀 수 있다. 

한개의 추상 메서드를 포함하는 인터페이스를 함수형 인터페이스라 부르며 자바8에서 용어를 처음 소개했다. @FunctionalInterface 애너테이션을 이용하면 인터페이스의 의도를 명확하게 할수있다.

### 3.4.2 람다 표현식

하지만 새로운 요구사항이 있을 때마다 별도의 클래스를 만들어야한다. 이는 큰의미가 없는 코드를 반복해서 만드는 귀찮은작업이다. 람다표현식의 문법과 언어 기능은 크게걱정하지말자 람다표현식을 이용해 이름 없이 인터페이스 구현 객체를 코드 블록 형태로 
요약하자면 다음과 같은 장점 덕분에 개방 폐쇄 원칙을 ㅏㅅ용한다. 

- 기존 코드를 바꾸지 않으므로 기존 코드가 잘못될 가능성이 줄어든다.
- 코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다. 
- 결합도가 낮아지므로 코드 유지보수성이 높아진다.

## 3.5 인터페이스 문제

갓 인터페이스의 문제. 모든 헬퍼연산이 명시적인 API정의에 포함되면서 인터페이스가 복잡해진다. 
- 자바의 인터페이스는 모든 구현이 지켜야 할 규칙을 정의한다. 즉 구현 클래스는 인터페이스에서 정의한 모든 연산의 구현 코드를 제공해야한다. 따라서 인터페이스를 바꾸면 이를 구현한 코드도 바뀐내용을 지원하도록 갱신되어야한다. 더많은 연산을 추가할수록 더 자주 코드가 바뀌며 문제가 발생할 수 있는 범위또한 넓어진다.
- 월, 카테고리같은 속성이메서드의 일부로 사용되었다. 인터페이스가 도메인 객체의 특정 접근자에 종속되는 문제가 생긴다. 도메인 객체의 세부 내용이 바뀌면 인터페이스도 바뀌어야하며 결과적으로 구현코드도 바뀐다. 이런 이유에서 보통 작은 인터페이스를 권장한다. 그래야 도메인 객체의 다양한 내부 연산으로 의 디펜던시를 최소화할 수 있다.

### 3.5.2 지나친 세밀함

지나치게 인터페이스가 세밀해도 코드 유지보수에 방해가된다. 안티응집도 문제가 발생한다. 즉 기능이 여러 인터페이스로 분할되므로 필요한 기능을 찾기가 어렵다. 자주 사용하는 기능을 쉽게 찾을 수 있어야 유지보수성도 좋아진다. 더욱이 인터페이스가 너무 세밀하면 복잡도 향상, 새로운 인터페이스가 계속해서 프로젝트에 추가된다.

## 3.6 명시적 API vs 암묵적 API

개방 폐쇄 원칙을 적용하면 연산에 유연성을 추가하고 가장 공통적인 상황으 ㄹ클래스로 정의할 수 있다. 둘다 장단점이있는데 구체적인 메서드는 자체적으로 어떤 동작을 수행하는지 잘 설명되어있고 사용하기 쉽다. API의 가독성을 높이고 쉽게 이해하도록 메서드 이름을 서술적으로 만들었다.하지만 이메서드의 용도가 특정 상황에 국한되어 각 상황에 맞는 새로운 메서드를 많이 만들어야하는 상황이 발생. 반면 암묵적은 처음 사용하기가 어렵고 문서화를 잘해놓아야한다. 하지만 거래 내역을 검색하는데 필요한 모든 상황을 단순하게 처리가능. 

### 3.6.1 도메인 클래스 vs 원시값



## 3.7 다양한 형식으로 내보내기

### 3.7.2 적절하게 인터페이스를 정의하고 구현하기

내보낼 형식이 무엇인지를 파악했으므로 이를 구현하는 API가 필요하다. Exporter 라는 인터페이스를 정의해서 다양한 내보내기 구현 코드가 다른 코드와 결합되지 않도록 방지한다.