# 도커 엔진

## 2.1 도커 이미지와 컨테이너

도커 엔진에서 사용하는 기본단위는 이미지와 컨테이너이며, 이 두가지가 도커 엔진의 핵심이다.

### 2.1.1도커 이미지

이미지는 컨테이너를 생성할 때 필요한 요소이며 가상 머신을 생성할 때 사용하는 iso파일과 비슷한 개념이다. 이미지는 여러 개의 계층으로 된 바이너리 파일로 존재하고 컨테이너를 생성하고 실행할 때 읽기 전용으로 사용된다. 이미지는 도커 명령어로 내려받을수 있으므로 별도로 설치할 필요는 없다.


- 저장소이름은 이미지가 저장된 장소를의미한다. 저장소 이름이 명시되지 않은 이미지는 도커에서 기본적으로 제공하는 이미지 저장소인 도커 허브의 공식 이미지를 뜻한다. 그러나 이미지를 생성할 때 저장소 이름을 명시할 필요는 없으므로 생략하는 경우도 있다.
- 이미지 이름은 해당 이미지가 어떤 역할을 하는지 나타낸다.
- 태그는 이미지의 버전관리 혹은 리비전관리에 사용한다. 일반적으로 버전을생략하면 latest로 인식



### 2.1.2 도커 컨테이너

이러한 이미지로 컨테이너를 생성하면 해당 이미지의 목적에 맞는 파일이 들어있는 파일시스템과 격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립된 공간이 생성되고 이것이바로 도커 컨테이너가된다. 대부분의 도커 컨테이너는 생성될 때 사용된 도커이미지의종류에 따라 알맞은 설정과 파일을 가지고 있기 때문에 도커 이미지의 목적에 맞도록 사용되는 것이 일반적이다. 예를 들어 웹서버 도커이미지로부터 여러개의 컨테이너를 생성하면생성된 컨테이너의 개수만큼 웹서버가 생성되고, 이 컨테이너들은 외부에 웹 서비스를 제공하는데 사용될 것이다.

컨테이너는 이미지를 읽기 전용으로 사용하되 이미지에서 변경된 사항만 컨테이너 계층에 저장하므로 컨테이너에서 무엇을 하든지 원래 이미지는영향을 받지 않는다. 


## 2.2 도커 컨테이너 다루기

### 2.2.1 컨테이너 생성 


docker run 명령어는 컨테이너를 생성하고 실행하는 역할을 한다. ubuntu:14.04 는 컨테이너를 생성하기 위한 이미지 이름이며, -i-t옵션은 컨테이너와 상호 입출력을 가능하게 한다. 이러한 옵션은 뒤에서 다시 설명한다.

`docker run -i -t ubuntu:14.04`

아래 명령어를 입력하면 다음과 같은 내용이 출력된다. 이미지가 로컬 도커 엔진에 존재하지 않으므로 도커 중앙 이미지 저장소인 도커 허브에서 자동으로 이미지를 내려 받는다. 


컨테이너에서 기본 사용자는 root 고 호스트이름은 무작위의 16진수 해시값이다. 무작위의 16진수 해시 값은 컨테이너의 고유한 id의 앞 일부분이다.

docker run 명령어로 컨테이너를 생성할 때 -i 옵션은 상호 입출력을 -t옵션으로 tty를 활성화해서 배시 셸로 사용하도록 컨테이너를 설정한다. 컨테이너와 호스트의 파일 시스템은 독립적이므로 ls명령어로 파일시스템을 확인해보면 아무것도 설치되지 않은 상태임을 확인할 수 있다.

컨테이너 내부에서 호스트의 도커 환경으로 돌아오려면 두가지가있다. 첫번째는 exit을 입력하거나ctrl + D를 입력하는 것이다. 그러나 이방법은 컨테이너 내부에서 빠져나오면서 동시에 컨테이너를 정지시킨다. 여기서는 exit를 이용한다. 

컨테이너를 정지하지 않고 빠져나오는 것으로는 Ctrl + P,Q를 입력하면된다.

이미지를 내려받을 때는 pull명령어를 사용한다.

`docker pull centos:7`

도커엔진에 존재하는 이미지 목록을 보려면 docker images 를 찍는다.

`docker images`

`docker create -i -t --name mycentos centos:7`


create 명령어로 출력된 무작위의 16진수 해시값은 컨테이너의 고유id이다. 그러나 너무 길어 일반적으로 앞의 12자리만 사용한다. docker inspect 명령어로 컨테이너의 id를 다시 확인할 수 있다.

이번에는 run 명령어를 실행했을 때와 달리 컨테이너 내부로 들어가지 않는다. create 명령어는 ㅓㄴ테이너를 생성만 할 뿐 컨테이너로 들어가지는 않는다.

docker start 명령어와 docker attach 명령어를 써서 컨테이너를 시작하고 내부로 들어갈 수 있다. attach 명령어는 컨테이너 내부로 들어가는 명령이다.


ctrl pq는 컨테이너를 정지시키지 않고 컨테이너에서 빠져나온다. run 명령어는 pull create start 명령어를 일괄적으로 실행한 후 attach 가 가능한 컨테이너라면 컨테이너 내부로 들어간다. 


### 2.2.2 컨테이너 목록 확인

`docker ps`
컨테이너 목록확인한다.이명령어는 정지되지 않은 컨테이너만 출력한다. exit으로 빠져나온 컨테니어는 정지 상태이기 때문에 목록에 출력되지 않지만 ctrl pq 로 빠져나온 컨테이너는 실행중이기 때문에 컨테이너 목록에 출력된다.

정지된 컨테이너포함한 모든 컨테이너를 출력하려면 -a옵션을 추가한다. 컨테이너의 상태는 STATUS항목에서 확인한다. 

`docker rename 컨테이너이름 바꾸고싶은이름`

### 2.2.3 컨테이너 삭제 
더이상 사용하지 않는 컨테이너를 삭제할 때는 docker rm 명령어를 사용한다. 한번 삭제한 컨테이너는 복구할 수 없으므로 삭제할 때는 신중해야한다. 


`docker rm 컨테이너이름`


`docker container prune`

이 명령어는 중지된 컨테이너를 모두 삭제한다. 


docker ps 명령어의 옵션과 -q옵션을 조합해 컨테이너를 삭제할 수 있다. -a는 컨테이너의 상태와관계없이 모든 컨테이너를 -q는 컨테이너의 id만들 출력하는 역할을 한다. 

`docker ps -a -q`

이 옵션들을 사용해서 출력된 컨테이너 리스트를 변수로 컨테이너를 삭제하면 모든 컨테이너를 간단히 삭제할 수 있다. 즉 다음 명령어는 컨테이너의 실행 상태와 관계없이 모든 컨테이너를 정지하고 삭제한다.


`docker stop $(docker ps -a -q)`

`docker stop $(docker ps -a -q)`


컨테이너를 삭제하면 컨테이너의 데이터를 모두 잃게 되므로 연습용으로 도커를 활용한 경우에만 위 명령어를 사용해야한다.


### 2.2.4 컨테이너를 외부에 노출

컨테이너는 가상 머신과 마찬가지로 가상 IP주소를 할당받는다. 기본적으로 도커는 컨테이너에 172.17.0.x의 ip를 순차적으로 할당한다. 컨테이너를 새롭게 생성후  ifconfig명령어로 컨테이너의 네트워크 인터페이스를 확인한다.


아무런 설정을 하지 않으면 컨테이너는 외부에서 접근할 수 없으며 도커가 설치된 호스트에서만 접근할 수 있다. 외부에 컨테이너의 애플리케이션을 노출하기 위해서는 eth0 의 ip와 포트를 호스트의 ip와 포트에 바인딩해야한다.

-p옵션은 컨테이너의 포트를 호스트 포트와 바인딩해 연결할 수 있게 설정한다. -p옵션의 입력형식은 다음과같다. 

[호스트 포트]:[컨테이너의 포트]

호스트의 7777번 포트를 컨테이너의 80번 포트와 연결하려면 7777:80과 같이 입력하며, 호스트의 특정 ip를 사용하려면 192.168.0.100:7777:80과 같이 바인딩할 ip와 포트를 명시한다. 또한 여러개의 포트를 외부에 개방하려면 -p옵션을 여러번 써서 설정한다.

아파치 웹서버는 기본적으로 80번 포트를 사용하므로 여기서는 컨테이너의 80번 포트를 호스트와 연결한다. 

도커의 포트포워딩 기능옵션인 -p를 사용해서 호스트와 컨테이너를 연결한다. 


### 2.2.5 컨테이너 애플리케이션 구축


대부분의 서비스는 단일 프로그램으로 동작하지 않는다. 여러 에이전트나 데이터베이스등과 연결되어 완전한 서비스로써 동작하는 것이 일반적이다.

이런 서비스를 컨테이너화 할 때 여러개의 애플리케이션을 한 컨테이너에 설치할 수도 있다. 그러나 컨테이너에 애플리케이션을 하나만 동작시키면 컨테이너 간의 독립성을 보장함과 동시에 애플리케이션의 버전관리, 소스코드 모듈화등이 더욱 쉬워진다. 도커이미지와 컨테이너의 돍립성을 유지하기 위해 나눠서 관리. 이 같은 구조는 도커 커뮤니티 뿐 아니라 도커 공식 홈페이지에서도 권장하는 구조이다. 한컨테이너에 프로세스 하나만 실행하는 것이 도커의 철학이기 때문이다.

-d는 컨테이너를 detached 모드로 실행한다. 백그라운드에서 동작하는 애플리케이션으로써 실행하도록 설정한다.

-d 옵션으로 run을 실행하면 입출력이 없는 상태로 컨테이너를 실행한다. 컨테이너 내부에서 프로그램이 터미널을 차지하는 포그라운드로 실행돼 사용자의 입력을 받지않는다. detached 모드인 컨테이너는 반드시 컨테이너에서 프로그램이 실행돼야하며, 포그라운드 프로그램이 실행되지 않으면 컨테이너는 종료된다.

mysql은 하나의 터미널을 차지하는 mysqld를 워드프레스는 하나의 터미널을 차지하는 apache2-foreground를 실행하므로 -d옵션을 지정해 백그래운드로 설정한 것이다. 

예를 들어보자

`docker run -d --name detach_test ubuntu:14:04` 컨테이너가 생성 되었다고 하더라도 바로 종료되므로 docker ps명령으로 확인할 수 없다. docker ps -a 명령어로 컨테이너의 상태를 확인하면 exited 상태인 것을 알수 있다. mysql 이미지는 컨테이너가 시작될 때 mysqld가 동작하도록 설정돼있기 때문이다. 이 상태에서는 상호 입출력이 불가능하고 단순히 프로그램이 포그라운드 모드로 동작하는 것만 지켜볼 수 있다. 이같은 이유로 -d옵션을 설정해 컨테이너가 백그라운드에서 동작하게 하는 것이다.

-e옵션은 컨테이너 내부의 환경변수를 설정한다. 컨테이너화된 애플리케이션은 환경변수에서 값을 가져와 쓰는 경우가 많으므로 자주 사용하는 옵션중 하나이다. mysql 컨테이너를 생성할 때 설정한 -e 옵션의 값을 살펴보면 mysql컨테이너의 환경변수로 어떤 것이 설정됐는지 알 수 있다.

컨테이너 내부에서 환경변수를 확인하는 가장 간단한 방법은 echo이다.

echo ${ENVIRONMENT_NAME}

컨테이너 내부에서 echo 로 환경변수를 출력하면  -e 옵션에 입력된대로 값이 설정돼 있음을 확인할 수 있다.

exec명령어를 이용하면 컨테이너 내부의 셸을 사용할 수 있다. 다음 명령어를 입력하면 mysql내부에 /bin/bash 프로세를 실행하고 -i-t 옵션을 사용해 배시셸을 쓸 수 있게 유지한다.

`docker exec -i -t wordpressdb /bin/bash`

설정된 환경변수가 mysql에 사용됐는지 확인하려면 컨테이너 내부에서 mysql -u root -p를 입력한뒤 password 를 입력한다.

컨테이너를 빠져나오려면 ctrl + PQ를 입력한다. 또는 /bin/bash 프로세스를 종료하려면 exit 를 입력한다. exec로 mysql컨테이너에 들어왔을 때는 exit을 써도 컨테이너가 종료되지 않는데, 이는mysql프로세스가 컨테이너 안에서 여전히 포그라운드 모드로 동작하고 있기 때문이다.

> --link A컨테이너에서 B컨테이너로 접근하는 방법중 가장 간단한 것은 NAT로 할당받은 내부 IP를 활용하는 것이다. B컨테이너의 IP가 172.17.0.3이라면 A컨테이너는 이 IP를 써서 B컨테이너에 접근할 수 있다. 그러나 도커엔진은 컨테이너에게 내부 IP를 3,4이런식으로 순차적으로할당한다. 이는 컨테이너를 시작할 때마다 재할당하는 것이므로 매번 변경되는 컨테이너의 IP로 접근하기는 어렵다. --link옵션은 내부 ip를 알필요없이 항상 컨테이너에 별명으로 접근하도록 설정한다. 
> `--link wordpressdb:mysql`
> 이는 컨테이너의 이름을 mysql로 설정한 것이다.
> 즉 워드프레스 웹서버 컨테이너는 wordpressdb의 ip를 몰라도 mysql이라는 호스트명으로 접근할 수 있게된다. 워드프레스 웹 서버 컨테이너에서mysql이라는 호스트이름으로ping을 전송하면 wordpressdb의 내부 ip로 접근하는 것을 확인할 수 있다.

start stop restart 등 명령어를 사용할 때는 여러개의 컨테이너 이름을 순서대로 입력할 수도 있다.

### 2.2.6 도커 볼륨

도커 이미지로 컨테이너를 생성하다보면 이미지는 읽기 전용이 되며 컨테이너의 변경 사항도 별도로 저장해서 각 컨테이너의 정보를 보존한다. 이미 생성된 이미지는 어떠한 경우로도 변경되지 않으며 컨테이너 계층에 원래 이미지에서 변경된 파일시스템을 저장한다. 이미지에 mysql을 실행하는데 필요한 애플리케이션 파일이 들어있다면 컨테이너 계층에는 워드펠스에서 쓴 로그인 정보나 게시글등과 같이 데이터베이스를 운용하면서 쌓이는 데이터가 저장된다.

그러나 여기에는 치명적인 단점이있다. mysql컨테이너를 삭제하면 컨테이너 계층에 저장되어있던 데이터 베이스 정보도 삭제된다는 점이다. 도커의 컨테이너는 생성과 삭제가 매우 쉬우므로 컨테이너를 삭제하면 데이터를 복구할 수 없게된다. 이를 방지하기 위해 컨테이너의 데이터를 영속적 데이터로 활용가능한 방법이 몇가지있다. 그중 가장 활용하기 쉬운 방법이 바로 볼륨을 활용하는 것이다.

호스트와 볼륨을 공유할 수 있고, 볼륨 컨테이너를 활용할 수 있으며 도커가 관리하는 볼륨을 생성할 수도있다.


-v /home/wordpress_db:/var/lib/mysql 이는 호스트의 디렉터리와 컨테이너의 /var/lib/mysql디렉터리를 공유한다는 뜻이다. 즉 호스트공유디렉터리:컨테이너 공유 디렉터리 형태이다.

/var/lib/mysql 디렉터리는 mysql이 데이터베이스의 데이터를 저장하는 기본 디렉터리이다.

실제로 /home/wordpress_db를 생성하지 않았더라도 도커는자동으로 이를 생성한다. 실제로 해당 디렉터리에 데이터베이스 관련 파일이 있는지 확인해보자.

-v옵션을 통한 호스트 볼륨 공유는 호스트의 디렉터리를 컨테이너의 디렉터리에 마운트한다.

볼륨을 사용하는 두번 째 방법은 -v옵션으로 볼륨을 사용하는 컨테이너를 다른 컨테이너와 공유하는 것이다. 컨테이너를 생성할 때 --volumes-from 옵션을 설정하면 -v 또는 --volume옵션을 적용한 컨테이너의 볼륨 디렉터리를 공유할 수 있다. 그러나 이는 직접 볼륨을 공유하는 것이 아닌 -v옵션을 적용한 컨테이너를 통해 공유하는 것이다. 

볼륨을 활용하는 세번째 방법은 docker volume명령어를 사용하는 것이다. 볼륨을 다루는 명령어는 docker volume으로 시작하며, docker volume create  명령어로 볼륨을 생성한다. 

`docker volume create --name myvolume`

`docker volume ls `명령어를 사용해 생성된 볼륨을 확인한다.

볼륨의 이름: 컨테이너의 공유 디렉터리


-v myvolume:/root/

도커 볼륨도 여러개의 컨테이너에 공유되어 활용 될 수 있다.

볼륨은 디렉터리 하나에 상응하는 단위로서 도커엔진에서 관리한다. 도커 볼륨도 호스트 볼륨 공유와 마찬가지로 호스트에 저장함으로써 데이터를 보존하지만 파일이 실제 어디에 저장되는지 사용자는 알 필요가 없다.

docker inspect 명령어를 사용하면 myvolume 볼륨이 실제로 어디에 저장되어있는지 알 수 있다.


### 2.2.7  도커 네트워크

컨테이너의 네트워크 인터페이스에 eth0과 lo네트워크 인터페이스가 있다. 도커는 컨테이너 내부 ip를 순차적으로 할당하며, 이 ip는 컨테이너를 재시작 할 때마다 변경될 수 있다. 이 내부 ip는 도커가 설치된 호스트 즉, 내부망에서만 쓸 수 있는 ip이므로 외부와 연결될 필요가 있다. 이과정으 ㄴ컨테이너를 시작할 때마다 호스트에 veth...라는 네트워크 인터페이스를 생성함으로써 이뤄진다. 도커는 각 컨테이너에 외부와의 네트워크를 제공하기 위해 컨테이너마다 가상 네트워크 인터페이스를 호스트에 생성하며 이 인터페이스 이름은 veth로 시작한다. veth인터페이스는 사용자가 직접 생성할 필요는 없으며 컨테이너가 생성될 때 도커엔진이 자동으로 생성한다. veth에서 v는 virtual를 뜻한다. 즉 virtual eth라는 의미이다.

컨테이너의 eth0인터페이스는 호스트의 veth라는 인터페이스와 연결됐으며 veth 인터페이슨느 docker0브리지와 바인딩돼 외부와 통신할 수 있다.

도커에서 기본적으로 쓸 수 있는 네트워크를 알아보자.

`docker network ls`

브리지, 호스트 , 논 네트워크가 있다.
브리지 네트워크는 컨테이너를 생성할 때 자동으로 연결되는 docker0브리지를 활용하도록 설정돼있다. 이네트워크는 172.17.0.x ip대역을 순차적으로 컨테이너에 할당한다. 

`docker network create --driver bridge mybridge`

브릿지 타입의mybridge라는 네트워크를 생성했다. docker run 또는 create 명령어에 --net옵션의 값을 설정하면 컨테이너가 이 네트워크를 사용하도록 설정할 수 있다. 

--net 옵션으로 container 을 입력하면 다른 컨테이너의 네트워크 환경을 공유할 수 있다. 공유되는 속성은 내부 ip, 네트워크 인터페이스의 맥주소등이다. --net옵션의 값으로 container:[다른 컨테이터 id] 와 같이 입력한다.


도커의 DNS는 호스트 이름으로 유동적인 컨테이너를 찾을 때 주로 사용된다 가장 대표적인 예가 --link 옵션인데 이는 컨테이너의 ip가 변경돼도 별명으로 컨테이너를 찾을 수 있게 dns에의해 관리된다.

--net-alias 옵션 또한 --link 옵션과 비슷한 원리로 돌아간다. 도커는 기본 브리지 네트워크가아닌 사용자가 정의한 브리지 네트워크에 사용되는 내장 DNS서버를 가지며, DNS의 IP는 127.0.0.11이다.


### 2.2.8 컨테이너 로깅

컨테이너 내부에서 어떤 일이 일어나느지 아는 것은 디버깅뿐만아니라 운영 측면에서도 중요하다. 애플리케이션 레벨에서 로그가 기록되도록 개발해 별도의 로깅 서비스를 쓸 수도 있지만 도커는 컨테이너의 표준출력과 에러 로그를 별도의 메타데이터 파일로 저장하여 이를 확인하는 명령어를 제공한다. 

먼저 컨테이너를 생성해 간단한 로그를 남겨보자.




### docker daemon not running 오류에 대하여.


```
cd "C:\Program Files\Docker\Docker"
./DockerCli.exe -SwitchDaemon

```

이 명령어로 도커 데몬을 다시 실행 mysql 과 같은 애플리케이션을 구동하는 컨테이너는 포그라운드 모드로 실행되므로 -d옵션을 써서 백그라운드 모드로 컨테이너를 생성하는 경우가 많다. 따라서 애플리케이션이 잘 구동되는 지 여부를 알수 없지만 docker logs명령어를 써서 컨테이너의 표준 출력을 확인함으로애플리케이션의 상태를 알 수 있다. 
mysql에 환경변수를 설정하지 않으면 컨테이너가 시작되지 않는다. 이처럼 컨테이너가 정상적으로 실행및 동작하지 않고  docker attach 명령어도 사용하지 못하는 개발환경에서 docker logs 명령어를 쓰면 간단하고 빠르게 에러를 확인할 수 있다.

컨테이너의 로그가 너무많아서 읽기 힘들다면  --tail 옵션을 써서 마지막 로그줄부터 출력할  줄의 술을 설정할 수 있다. 다음예시에서는 컨테이너의 로그중 마지막 2줄만 출력한다.

```docker logs --tail 2 mysql```


--since 옵션에 유닉스 시간을 입력해서 특정 시간 이후의 로그를 확인할 수 있으며 -t옵션으로 타임스탬프를 표시할 수 있다.컨테이너에서 실시간으로 출력되는 내용을 확인하려면 -f옵션을 써서 로그를 스트림으로 확인할 수 있다. 특히 -f 옵션은 애플리케이션을 개발할 때 유용하다. 

`docker logs --since 1474765979 mysql`

타임스탬프 표시  -f옵션으로 로그를 스트림으로확인 


docker logs 명령어는 run 명령어에서 -i -t 옵션을 설정해 docker attach 명령어를 사용할수있는 컨테이너에도 쓸 수 있으며 컨테이너 내부에서 bash 셸등 입출력한 내용을 확인할 수도 있다.

컨테이너 로그는 JSON형태로 도커 내부에 저장된다. 이파일은 다음 경로에 컨테이너의 ID로 시작하는 파일명으로 저장된다. 
어떠한 설정도 하지 않았다면 도커는 위와 같은 형태로 로그를 JSON파일로 저장하지만 그 밖에도 각종 로깅 드라이버를 사용하게 설정해 컨테이너 로그를 수집할 수 있다. 사용가능한 드라이버의 대표적인 예로 syslog, journald, fluentd, awslogs 등이 있으며 애플리케이션의 특징에 적합한 로깅 드라이버를 선택한다.

로깅 드라이버는 기본적으로 json-file로 설정되지만 도커 데몬 시작 옵션에서  --log-driver 옵션을 써서 기본적으로 사용할 로깅 드라이버를 변경할 수 있다. 



#### 2.2.8.1 syslog로그

컨테이너의 로그는 JSON뿐만 아니라 syslog로 보내 저장하도록 설정할 수 있다. syslog는 유닉스 계열 운영체제에서 로그를 수집하는 오래된 표준중 하나로서, 커널 보안등 시스템과 관련된 로그, 애플리케이션의 로그등 다양한 종류의 로그를 수집해 저장한다. 
대부분의 유닉스 계열 운영체제에서는 syslog를 사용하는 인터페이스가 동일하기 때문에 체계적으로 로그를 수집하고 분석할 수 있다는 장점이있다.

```
docker run -d --name syslog_container --log-driver=syslog ubuntu:14.04 echo syslogtest
```

syslog 로깅 드라이버는 기본적으로 로컬 호스트의 syslog에 저장하므로 운영체제및 배포한에 따라 syslog 파일의 위치를 알아야 이를 확인할 수 있다. 

syslog를 원격 서버에 설치하면 로그 옵션을 추가해 로그 정보를 원격 서버로 보낼 수 있다. 이번에는 syslog를 원격에 저장하는 방법의 하나인 rsyslog를 써서 중앙 컨테이너로 로그를 저장해보자. 
서버 호스트에 rsyslog 서비스가 시작하도록 설정된 컨테이너를 구동하고 클라이언트 호스트에서 컨테이너를 생성해 서버의 rsyslog컨테이너에 로그를 저장한다. 

--log-opt는 로깅드라이버에 추가할 옵션을 뜻하며, syslog-address에 rsyslog컨테이너에 접근할 수 있는 주소를 입력한다. tag는 로그데이터가 기록될 때 함께 저장될 태그이며 로그를 분류하기 위해 사용한다.

```
docekr run -i -t --log-driver syslog
```

#### 2.2.8.3 fluentd 로깅

각종 로그를 수집하고 저장할 수 있는 기능을 제공하는 오픈소스 도구로서, 도커엔지느이 컨테이너의 로그를 fluentd 를 통해 저장할 수 있도록 플러그인을 공식적으로 제공한다. fluentd 은 데이터 포맷으로JSON을 사용하기 때문에 쉽게 사용할 수 있을 뿐만아니라 수집되는 데이터를 AWS S3, MongoDB등 다양한 저장소에 저장할 수 있다는 장점이있다.

도커엔진은 fluentd 서버에 컨테이너의 로그를 전송하고 이로그는 다시 몽고DB서버로 전송되어 저장된다.

#### 2.2.8.4 아마존 클라우드 워치 로그

AWS에서는 로그및 이벤트등을 수집하고 저장해 시각적으로 보여주는 클라우드 워치를 제공한다. 도커를 AWS EC2에서 사용하고 있다면 다른 도구를 별도로 설치할 필요 없이 컨테이너에서 드라이버옵션을 설정하는 것만으로 클라우드 워치 로깅드라이버를 사용할 수 있다. 
-  IAM권한 생성
-  로그 그룹 생성
-  로그 그룹에 로그 스트림 생성
-  클라우드 워치 IAM권한을 사용할 수 있는 EC2인스턴스 생성과 로그 전송


IAM 권한을 사용하도록 설정한 EC2인스턴스의 도커엔진에서 다음 명령어를 입력해 컨테이너를 생성한다. 로깅 드라이버로 awslogs를 사용할 수 있게 설정하고 로그 그룹과 스트림은  mylogs 와 mylogstream을 사용한다. 


### 2.2.9 컨테이너 자원 할당 제한

컨테이너를 생성하는 run, create 명령어에서 컨테이너의 자원 할당량을 조정하도록 옵션을 입력할 수 있다.

아무런 옵션을 입력하지 않으면 컨테이너의 호스트의 자원을 제한 없이 쓸수 있게 설정되므로 제품 단계의 컨테이너를 고려한다면 컨테이너의 자원 할당을 제한해 호스트와 다른 컨테이너의 동작을 방해하지 않게 설정하는 것이 좋다. 컨테이너에 자원 할당 옵션을 설정하지 않으면 호스트의 자원을 전부 점유해 다른 컨테이너들뿐아니라 호스트 자체의 동작이 멈출수 있다.

#### 2.2.9.1 컨테이너 메모리 제한 

docker run 명령어에 --memory 를 지정해 컨테이너의 메모리를 제한할 수 있다. 입력할 수 있는 단위는 m , g 이며 제한할 수 있는 메모리는 4mb입니다. 

컨테이너 내에서 동작하는 프로세스가 컨테이너에 할당된 메모리를 초과하면 컨테이너는 자동으로 종료되므로 애플리케이션에 따라 메모리를 적절하게 할당하는 것이 좋다. 


#### 2.2.9.2 컨테이너 CPU제한

--cpu-shares

가상 머신이 특정 개수의 CPU를 할당받는 것과는 다르게 모든 컨테이너의 작업은 CPU스케줄링에서 같은 비율로 처리된다. 따라서 컨테이너 하나에 CPU를 한개 할당하는 방식이 아닌 CPU스케줄링에서 CPU를 얼마나 많이 차지할 것인가를 설정해야한다. 
--cpu-shares 옵션은 상대적인 값을 가진다. 아무런 설정을 하지 않았을 때 컨테이너가 가지는 값은 1024로서 이는 CPU할당에서 1의 비율을 뜻한다. 즉 위의 예제와 같이 컨테이너의 --cpu-shares 를 2048로 설정하면cpu작업시 일반 컨테이너 보다 2배 많은 양을 할당받는다.

stress라는 명령어는 CPU와 메모리에 과부하를 줘서 성능을 테스트한다. 우분투 컨테이너에는 다음 명령어로 설치할 수 있다. 

`apt-get install stress`

--cpuset-cpu

호스트에 cpu가 여러개 있을 때 --cpuset-cpus옵션을 지정해 컨테이너가 특정 CPU만 사용하다록 설정할 수 있다. CPU집중적인 작업이 필요하다면 여러개의 CPU를 사용하도록 설정해 작업을 적절하게 분배하는 것이 좋다. 


#### 2.2.9.3 Block I/O제한

컨테이너를 생성할 때 아무런 옵션도 설정하지 않으면 컨테이너 내부에서 파일을 읽고 쓰는 대역폭에 제한이 설정되지 않는다. 하나의 컨테이너가 블록 입출력을 과도하게 사용하지 않게 설정하려면  run 명령어에서--device-write-bps ,--device-read-bps, --device-write-iops, --device-read-iops옵션을 지정해 블록 입출력을 제한할 수 있다. 

#### 2.2.9.4 컨테이너 저장 공간 설정

컨테이너 내부에서 사용되는 파일시스템의 크기는 도커가 사용하고 있는 스토리지 드라이버에 따라 조금씩 다르다. 


`df -h ` 로 파일 시스템 크기 확인 가능



## 2.3 도커 이미지

모든 컨테이너는 이미지르 ㄹ기반으로 생성되므로 이미지를 다루는 방법은 도커 관리에서 빼놓을 수 없는 부분이다. 이미지의 이름을 구성하는 저장소 이미지 이름 , 태그를 잘 관리하는 것 뿐만아니라 이미지가 어떻게 생성되고 삭제되는지, 이미지의 구조는 어떻게 돼 있는지 등을 아는 것 또한 중요하다. apt-get install 을 실행하면 apt레포지터리에서 패키지를 내려받고 레드햇 운영체제에서 yum install을 실행하면 yum 리포지터리에서 패키지를 내려받듯이 도커는 기본적으로 도커 허브라는 중앙 이미지 저장소에서 이미지를 내려받는다 도커 허브는 도커가 공식적으로 제공하고 있는 이미지 저장소로서 도커 계정을 가지고 있다면 누구든지 이미지를 내려받을 수 있기 때문에 다른 사람들에게 이미지를 쉽게 공유할 수 있다.



### 2.3.2 이미지 구조 이해

이미지를 좀더 효율적으로 다루기 위해 컨테이너가 어떻게 이미지로 만들어지며, 이미지의 구조는 어떻게 돼 있는지 알필요가 있다. 다음 명령어를 입력해 이미지의 좀더 자세한 정보를 확인해보자

```
docker inspect ubuntu:14.04
docker inspect commit_test:first
docker inspect commit_test:second
```


inspect 명령어는 컨테이너뿐만아니라 네트워크 볼륨 이미지등 모든 도커단위의 정보를 얻을 때 사용할 수 있다. 단 이름이 중복될 경우 컨테이너에 대해 먼저 수행되므로 --type을 명시하는 것이 좋다.


docker images 에서 3개의 이미지 크기가 188mb라고 출력해도 188mb 크기의 이미지가 3개존재하는 것은 아니다. 이미지를 커밋할 때 컨테이너에서 변경된 사항만 새로운 레이어로 저장하고 그 레이어를 포함해 새로운 이미지를 생성하기 때문에 전체 이미지의 실제 크기는 188mb + first 파일의 크기 + second 파일의 크기가된다. 


이미지를 삭제해보자 docker rmi 명령엉를 사용하면 이미지를 삭제할 수 있다.

```
docker rmi commit_test:first
```

이미지를 사용중인 컨테이너가 존재하면 해당 이미지를 삭제할 수 없다. 컨테이너를 삭제할 때 사용했던 docker rm -f 컨테이너이름  -f옵션을 추가해 이미지를 강제로 삭제할 수 있지만 이는 이미지 레이어 파일을 실제로 삭제하지 않고 이미지 이름만 삭제하기 때문에 의미가 없다. 따라서 다음 명령어와 같이 컨테이너를 삭제한뒤 이미지를 삭제하게 한다. 
```
docker stop commit_test2 && docker rm commit_test2
docker rmi commit_test:first


```

컨테이너가 이미 사용중인 이미지를 docker rmi -f 로 강제 삭제하면 이미지의 이름이 none으로 변경되고 이러한 이미지들을 댕글링 이미지라고 한다. 댕글링 이미지는  docker images -f dangling=true 명령어로 확인할 수 있고 사용중이지 않은 댕글링 이미지는 docker images prune 명령어로 한꺼번에 삭제가능하다.


### 2.3.3 이미지 추출

도커 이미지를 별도로 저장하거나 옮기는 등 필요에 따라 이미지를 단일 바이너리 파일로 저장해야 할 때가 있다.

docker save 명령어를 사용하면 컨테이너의 커맨드 이미지이름과 태그등 이미지의 모든 메타데이터를 포함해 하나의 파일로 추출할 수 있다. -o옵션에는 추출될 파일명을 입력한다.

```
docker save -o docker_14_04.tar ubuntu:14.04
```

추출된 이미지는 load명령어로 도커에서 다시 로드할 수 있다. save 명령어로 추출된이미지는 모든 메타데이터를 포함하기 때문에 load명령어로 이미지를 로드하면 이전의 이미지와 완전히 동일한 이미지가 도커엔진에 생성된다.


```
docker load -i ubuntu_14_04.tar
```


### 2.3.4 이미지 배포
이미지를 생성했다면 이를 다른 도커 엔진에 배포할 방법이 필요하다. save나 export 와 같은 방법으로 이미지를 단일 파일로 추출해서 배포할 수도 있지만 이미지 파일의 크기가 너무 크거나 도커엔진의 수가 많다면 이미지를 파일로 배포하기 어렵다. 또한 도커의 이미지 구조인 레이어 형태를 이용하지 않으므로 매우 비효율적이다.

이를 해결하는 첫번째 방법은 도커에서 공식적으로 제공하는 도커 허브 이미지 저장소를 사용하는 것이다. 도커 허브는 도커 이미지를 저장하기 위한 클라우드 서비스라고 생각하면 이해하기 쉽다. 사용자는 단지 이미지를 올리고 내려받기만 하면 되므로 매우 간단하게 사용할 수 있다. 단 결제를 하지 않으면 비공개 저장소의수에 제한이 있다는 단점이있다. 공개 저장소는 무료로 사용할 수 있으므로 만든 이미지를 다른 사용자에게도 공개해도 상관없다면 도커허브를 사용하는 것도 좋은 방법이다.

두 번째 방법으로는 도커 사설 레지스트리를 사용하는 것으로서 사용자가 직접 이미지 저장소를 만들수 있다. 그러나 사용자가 직접 이미지 저장소 및 사용되는 서버 저장공간등을 관리해야하므로 도커허브보다는 까다롭다. 그러나 회사의 내부방같은 곳에서 도커이미지를 배포해야한다면 도커 사설 레지스트리가 더 좋은 방안이 될 수 있다.

저장소에 이미지가 push 됐을 때 특정 URL로 http 요청을 전송하도록 설정할 수 있는데, 이기능을 웹훅이라고한다. 도커 허브의 웹훅 기능은 저장소에 새로운 이미지가 생성됐을 때 지정된 URL로 해당 이미지의 정보와 함께 http요청을 전송한다. 이 기능은 저장소에 추가된 새로운 이미지를 각 서버에 배포하는 애플리케이션을 작성할 때 유용하게 활용할 수 있다.


## 2.4 Dockerfile

컨테이너 생성 애플리케이션 설치 컨테이너 커밋해서 이미지로 만들기.

이 방법을 사용해면 애플리케이션이 동작하는 환경을 구성해서 일일이 수작업으로 패키지를 설치하고 소스코드를 깃에서 복제하거나 호스트에서 복사해야한다. 물론 직접 컨테이너에서 애플리케이션을 구동해보고 이미지로 커밋하기 때문에 이미지의 동작을 보장할 수 있다는 점도 있다.


도커는 위와같은 일련의 과정을 손쉽게 기록하고 수행할 수 있는 build 명령어를 제공한다.

완성된 이미지를 생성하기 위해 컨테이너에 설치해야하는 패키지, 추가해야하는 소스코드, 실행해야하는 명령어와 셸스크립트등을 하나의 파일에 기록해 두면 도커는 이 파일을 읽어 컨테이너에서 작업을 수행한뒤 이미지로 만들어낸다.

이러한 작업을 기록한 파일의 이름을 Dockerfile 이라고 한다.

 Dockerfile 은 애플리케이션을 개발하는 용도외에도 여러목적으로 사용될수 있다. 생성한 이미지를 도커허브등을 통해 배포할 때 이미지 자체를 배포하는 대신 이미지를 생성하는 방법을 기록해 놓은 Dockerfile을 배포할 수 있다.  배포되는 이미지를 신뢰할 수 없거나 직접 이미지를 생성해서 사용하고 싶다면 도커허브에 올려져있는 Dockerfile 로 빌드하는 것도 하나의 방법이다.

 Dockerfile 을 생성하는 것은 이미지를 생성하는 방법을 기록하는 것 뿐만아니라 이미지의 빌드, 배포 측면에서도 매우유리하다. 애플리케이션에 필요한 패키지 설치 등을 명확히 할 수 있고 이미지 생성을 자동화할 수 있으며, 쉽게 배포할 수 있기 때문이다.

 ### 2.4.2 Dockerfile 작성

 Dockerfile에는 컨테이너에서 수행해야할 작업을 명시한다. Dockerfile은 도커를 위한 특수한 파일인만큼 기존의 스크립트언어와 비교했을 때 완전히 새로운 방식으로 쓰이지만 컨테이너에서 사용되는 기초적인 명령어를 알기 쉽게 변환한 것으로 어렵지 않게 익힐수 있다.

 도커엔진은 Dockerfile을 읽어들일 때 기본적으로 현재 디렉터리에있는 Dockerfile 이라는 이름을 가진 파일을 선택한다. 명령어를 소문자로 표기해도 상관은 없지만 일반적으로 대문자로 표기한다.

 - MAINTAINER: 이미지를 생성한 개발자의 정보를 나타낸다. 일반적으로 이메일 입력
 - LABEL: 이미지에 메타데이터를 추가한다. 일반적으로 Dockerfile 을 작성한 사람과 연락할 수 있는 이메일 등을 입력한다. 단 MAINTAINER는 도커 1.13.0버전 이후로 사용하지 않는다. 여러개의 메타데이터가 저장될수 있다. 추가된 메타데이터는 docker inspect명령어로 이미지의 정보를 구해서 확인할 수 있다.
- RUN: 이미지를 만들기 위해 컨테이너 내부에서 명령어를 실행한다. Dockerfile 을 이미지로 빌드하는 과정에서는 별도의 입력이 불가능하기 때문에 -y 옵션 넣어야한다.이미지를 빌드할 때 별도의 입력을 받아서 하는 RUN이 있다면 build 명령어는 이를 오류로 간주하고 빌드를 종료한다.
- ADD: 파일을 이미지에 추가합니다. 추가하는 파일은 Dockerfile 이 위치한 디렉터리인 컨텍스트에서 가져온다. 배열의 마지막 원소가 컨테이너에 추가될 위치이다.
- WORKDIR: 명령어를 실행할 디렉터리를 나타낸다. 배시 쏄에서 cd 명령어를 입력하는 것과 같은 기능을 한다. WORKDIR명령어를 여러번 사용하면 cd명령어를 여러번 사용한 것과 같다.
- EXPOSE: Dockerfile 의 빌드로 생성된 이미지에서 노출할 포트를 설정한다. 그러나 EXPOSE를 설정한 이미지로 컨테이너를 생성했다고 해서 반드시 이 포트가 호스트의 포트와 바인딩되는 것은 아니며, 단지 컨테이너의 80번 포트를 사용할 것임을 나타내는 것이다. EXPOSE는 컨테이너를 생성하는 run 명령어에서 모든 노출된 컨테이너의 포트를 호스트에 퍼블리시하는 -P플래그와 함께 사용된다. 즉 CMD는 run 명령어의 이미지 이름 뒤에 입력하는 커맨드와 같은 역할을 하지만 docker run 명령어에서 커맨드 명령줄인자를 입력하면 Dockerfile 에서 사용한 CMD의 입력은 JSON 배열 형태로 한다. CMD는 ENTRYPOINT의 명령줄 인자로도 사용될 수 있다.

```Dockerfile
FROM ubuntu:14.04
MAINTAINER hyunjin
LABEL "purpose"="practice"
RUN apt-get update
RUN apt-get install apache2 -y
ADD test.html /var/www/html
WORKDIR /var/www/html
RUN ["/bin/bash", "-c", "echo hello >> test2.html"]
EXPOSE 80
CMD apachectl -DFOREGROUND
```

### 2.4.3 Dockerfile 빌드

도커의 기본적인 명령어를 이해했다면 Dockerfile 을 빌드해보자. 빌드명령어는 다음과 같다. 

> docker build -t mybuild:0.0 ./

-t옵션은 생성될 이미지의 이름을 설정한다. -t 를 사용하지 않으면 16진수 형태로 이미지이름이 생성되므로 가급적이면 -t 옵션을 사용하는 것이 좋다.
build 명령어의 끝에는 Dockerfile 이 저장된 경로를 입력한다.

일반적으로 로컬에 저장된 도커파일을 사용하지만 외부 URL로부터 도커파일의 내용을 가져와 빌드할 수도있다. 이 예시에서는 로컬에 Dockerfile을 저장했으므로 ./을 입력한다.

docker ps 또는 docker port 명령어로 컨테이너와 연결된 호스트의 포트를 알수 있으며 호스트의 IP와 이 포트로 컨테이너의 웹서버에 접근할 수 있다. Dockerfile 에서 ADD로 test.html 파일을 RUN으로 test2.html로 접근해 각 파일의 내용을 확인할 수 있다.

빌드 명령어를 입력했을 때 다양한 내용이 출력되었다. 내용중 대부분은 Dockerfile의 RUN을 실행해서 컨테이너 내부에서 발생한 표준 출력이지만, 이미지를 생성하는 부분은 조금 눈여겨볼 필요가있다. 이미지를 빌드하면 도커는 가장 먼저 빌드 컨텍스트를 읽어들인다. 빌드 컨텍스트는 이미지를 생성하는데 필요한 각종 파일 소스 코드 메타데이터등을 담고있는 디렉터리를 의미하며 Dockerfile 이 위치한 디렉터리가 빌드 컨텍스트이다.빌드 컨텍스트는 Dockerfile 에서 빌드될 이미지에 파일을 추가할 때 사용된다. Dockerfile 에서 이미지에 파일을 추가하는 방법은 앞에서 설명한 ADD외에도 COPY가 있는데, 이 명령어들은 빌드 컨텍스트의 파일을 이미지에 추가한다. 위 예제에서는 빌드 경로를 ./ 로 지정함으로써 test.html 파일을 빌드 컨텍스트에 추가했으며 , ADD명령어를 통해 빌드 컨텍스트에서 test.html 파일을 이미지에 추가했다.

컨텍스트는 build 명령어의 맨 마지막에 지정된 위치에있는 파일을 전부 포함한다. 루트 디렉터리와 같은 곳에서 이미지를 빌드하지 않도록 주의한다. 컨텍스트는 단순 파일뿐 아니라 하위 디렉터리도 전부 포함하게되므로 빌드에 불필요한 파일이 포함된다면 빌드 속도가 느려질뿐더러 호스트의 메모리를 지나치게 점유할 수도있다.

.dockerignore 라는 파일을 작성하면 빌드시 이 파일에 명시된 이름의 파일을 컨텍스트에서 제외한다. .dockerignore파일은 컨텍스트의 최상위 경로, 즉 build 명령어에서 맨 마지막에 오는 경로인 Dockerfile 이 위치한 경로와 같은 곳에 위치해야한다. 
.dockerignore의 제외 목록에 해당하지만 특수한 파일만 포함하도록 설정하고 싶다면 !를 사용한다. !는 특정 파일을 제외하지 않음을 뜻한다. 다음 예시는 확장자가 html 인 파일을 모두 제외하지만 test로 시작하는 html파일은 제외하지 않는다.

Dockerfile 을 이용한 컨테이너 생성과 커밋


빌드 명령어는 Dockerfile 에 기록된 대로 컨테이너를 실행한 뒤 완성된 이미지를 만들어낸다. 도커파일에서 명령어 한줄이 실행될 때마다 이전 Step에서 생성된 이미지에 의해 새로운 컨테이너가 생성되며 도커파일에 적힌 명령어를 수행하고 다시 새로운 이미지 레이어로 저장된다. 따라서 이미지의 빌드가 완료되면 도커파일의 명령어 줄 수만큼 레이어가 존재하게 되며, 중간에 컨테이너도 같은 수만큼 생성되고 삭제된다.Removing intermediate container 는 중간에 이미지 레이어를 생성하기 위해 임시로 생성된 컨테이너를 삭제하고 삭제되기전 출력되는 ID는 커밋된 이미지 레이어를 의미한다. 한번 이미지 빌드를 마치고 난뒤 다시 같은 빌드를 진행하면 이전의 이미지 빌드에서 사용했던 캐시를 사용한다. 

build 명령어의 -f 또는 --file 옵션으로 도커파일의 이름을 지정할 수 있다.
이미지 빌드중 오류가 발생했을 때는 build 명령어가 중지되며, 이미지 레이어 생성을 위해 마지막으로 생성된 임시 컨테이너가 삭제되지 않은 채로 남게된다. 또한 이미지의 빌드가 완전하지 않기 때문에 -t 옵션의 값으로 지젖오딘 이미지의 이름이 아닌 none:none 이미지가 생성된다. 도커파일에 RUn git clone 을 사용해 이미지를 빌드했다면 RUN에대한 이미지 레이어를 계속 캐시로 사용하기 때문에 실제 깃 저장소에서 리비전 관리가 일어나도 매번 빌드할 때마다 고저오딘 소스코드를 사용하게 될 것이다. 

이 경우 캐시를 사용하지 않으려면 build 명령어에 --no-cache옵션을 추가한다. 도커파일을 처음부터 이미지 레이어로서 빌드한다.

#### 2.4.3.3 멀티 스테이지를 이용한 Dockerfile 빌드하기

일반적으로 애플리케이션을 빌드할 때는 많은 의존성 패키지와 라이브러리를 필요로한다. 예를 들어 Go로 작성된 소스코드를 빌드하기위해서는 Go와 관련된 비륻툴과라이브러이가 설치 되어있어야한다. Dockerfile 에서 Go소스코드를 빌드하기 위해서 가장먼저 생각나는 방법은 아래의 Dockerfile 처럼 Go와 관련된 도구들이 미리 설치된 이미지를 FROM에 명시한뒤 RUN 명령어로  소스코드를 컴파일 하는 것이다. 

alpine 이나 busybox와 같은 이미지는 우분투나 CentOS에 비해 이미지 크기가 매우 작지만 기본적인 프로그램 실행에 필수적인 런타임 요소가 포함되어있는 리눅스 배포판 이미지이다. 이러한 이미지를 사용하면 경량화된 애플리케이션 이미지를 간단히 생성할 수 있다는 장점이있다. 이와 같은 멀티스테이지 빌드는 반드시 실행에 필요한 실행파일만 최종 이미지 결과물에 포함시킴으로써 이미지 크기를 줄일 때 유용하게 사용할 수 있다.

멀티 스테이지 빌드를 사용하는 Dockerfile 는 2개 이상의 이미지를 사용할 수 있으며, 각이미지는 먼저 FRO에서 명시된 순서대로 0 , 1,...의 순으로 차례대로 구분되어 사용된다. 

### 2.4.4 기타 도커파일 명령어

#### 2.4.4.1 ENV, VLLUME, ARG, USER

- ENV 도커파일에서 사용될 환경변수를 지정한다. 설정한 환경변수는 ${ENV_NAME} 또는 $ENV_NAME의 형태로 사용할 수 있다. 이환경변수는 도커파일뿐아니라 이미지에도 저장되므로 빌드된 이미지로 컨테이너를 생성하면 이 환경변수를 사용할 수 있다.

도커파일에서 환경변수의 값을 사용할 때 배시 셸에서 사용하는 것처럼 값이 설정되지 않은 경우와 설정된 경우를 구분해 사용할 수 있다. 
- VOLUME 빌드된 이미지로 컨테이너를 생성했을 때 호스트와 공유할 컨테이너 내부의 디렉터리를 설정한다. VOLUME 처럼 JSON배열의 형식으로 여러개를 사용하거나 스페이스바로 구분가능.
- ARG: build 명령어를 실행할 때 추가로 입력을 받아  Dockerfile 내에서 사용될 변수의 값을 설정한다. 다음 Dockefile 은 build 명령어에서 my_arg와 my_arg_2라는 이름의 변수를 추가로 입력받을 것이라고 ARG를 통해 명시한다. ARG의 값은 기본적으로 build명령어에서 입력받아야하지만 다음의 my_arg_2 와같이 기본값을 지정가능
```dockerfile
FROM ubuntu:14.04
ARG my_arg
ARG my_arg_2=value2
RUN touch ${my_arg}/mytouch
```

위 내용을 Dockerfile로 저장한뒤 이미지를 빌드하자. build 명령어를 실행할 때 --build-arg옵션을 사용해 dockerfile 의 arg에 값을 입력할 수 있다. 
```
docker build --build-arg my-arg=/home -t myarg:0.0 ./
```

- USER: USER로 컨테이너 내에서 사용될 사용자 계정의 이름이나 UID를 설정하면 그 아래의 명령어 는 애당 사용자 권한으로 실행된다. 일반적으로 RUN으로 사용자 그룹과 계정을 생성한뒤 사용한다. 루트 권한이 필요하지 않다면 USER를 사용하는 것을 권장.

```Dockerfile
RUN groupadd -r author && useradd -r -g author hyunjin
USER hyunjin
```

#### 2.4.4.2 Onbuild, Stopsignal, Healthcheck , Shell 


- STOPSIGNAL : 컨테이너가 정지될 때 사용될 시스템 콜의 종류를 지정한다. 아무것도 설정하지 않으며 기본적으로SIGTERM로 설정되지만 Dockerfile 에 STOPSIGNAL을 정의해 컨테이너가 종료되는데 사용될 신호를 선택할 수 있다. 


Dockerfile 의 STOPSIGNAL은 docker run 명령어에서 --stop-signal옵션으로 컨테이너에 개별적으로 설정할 수 있다. 이는 docker stop 뿐A만아니라 docker kill에도 사용된다.


- HEALTHCHECK: HEALTHCHECK는 이미지로부터 생성된 컨테이너에서 동작하는 애플리케이션의 상태를 체크하도록 설정한다. 컨테이너 내부에서 동작중인 애플리케이션의 프로세스가 종료되지는 않았으나 애플리케이션이 동작하고 있지 않은 상태를 방지하기 위해 사용될 수 있다.


- SHELL: SHELL ['/usr/local/bin/node']
노드를 기본셸로 사용한다.

#### 2.4.4.3 ADD, COPY

COPY는 로컬 디렉터리에서 읽어들인 컨텍스트로부터 이미지에 파일을 복사하는 역할을 한다.

ADD 명령어는 다음과 같이 사용할 수 있다.copy명령은 add에 포함된다. 

`ADD https://raw.githubusercontent.com/master/test.html /home`

또는 tar파일을 추가할 수도있다. tar파일을 자동 해체해서 추가한다. 그러나 ADD 를 사용하는 것은 권장되지 않는다. 그 이유는 ADD로 URL이나 tar파일을 추가할 경우 이미지에 정확히 어떤 파일이 추가될지 알 수 없기 때문이다. 그에 비해 COPY는 로컬 컨텍스트로부터 파일을 직접 추가하기 때문에 빌드 시점에서도 어떤 파일이 추가될지 명확하다.


#### 2.4.4.4