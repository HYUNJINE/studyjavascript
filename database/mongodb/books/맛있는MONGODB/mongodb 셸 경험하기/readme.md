CRUD

셸을 통해 컬렉션과 데이터베이스를 설정하는 방법을 알아보고 도큐먼트를 컬렉션에 생성하고 읽고 수정하고 삭제하는 작업에대해 다룰 것이다.

mongoDB 셸은 이러한 도큐먼트를 조작하는 여러가지 명령을 수행할 수 있다. 또한 셸은 명령을 수행할 때 다양한 옵션을 설정해서 다양한 상황에 대비할 수 있는 명령어를 갖추고있다.

사람들이 드나드는 웹사이트에는 종류가 있다. 그중 대부분의 웹사이트는 게시글 댓글 등의 소통기능을 기본적으로 탑재한다. 이번장에서는 커뮤니티의 기본적인 기능인 글쓰기, 글 삭제하기, 댓글 쓰기와 같은 작업을  MongoDB셸로 명령해보고 익히는 것을 목표로 삼는다.

이런 기능을 수행하기 위해서는 어떤 데이터를 저장할지 먼저 결정해야한다. 이처럼 어떤 컬렉션을 생성할 것인지 각각의 컬렉션에 도큐먼트의 모양은 어떻게 할 것인지 결정하는 작업을 모델링이라고한다. 

## 2.1 컬렉션과 데이터베이스 더알아보기

도큐먼트를 다루는 법에 대해 살펴보기에 앞서 우선 컬렉션과 데이터베이스에 대해 더 깊이 있게 배우고 넘어갈 필요가있다. 

- db.dropDatabase()
- db.collection.drop()
- db.collection.rename

데이터베이스의 이름은 한번 정한 상태에서 명령어로 간단하게 바꿀 수 없다. 스토리지 엔진의 구조적인 문제로 저장된 전체적인 내용이 바뀌어야하는데 복제와 샤딩까지된 상태에서 이것을 실시간으로 바꾸는 것은 불가능하기 때문이라고한다. 

> Capped 컬렉션과 뷰

Capped 컬렉션

디비안에는 사실 앞서 소개한 일반적인 컬렉션 외에 다른 요소가 담겨있을 수 있다. 첫번째로 소개할 요소는 바로 캡드컬렉션이다. 이 컬렉션은 일반 컬렉션과다르게 정해진 크기를 초과하게되면, 자동으로 가장 오래된 데이터를 삭제한다.

```
db.createCollection(<collection name >, {capped: true, size: <제한할 크기>})
```
사이즈 파라미터에 오는 부분은 바이트 단위의 숫자를 적어주게되면, 크기가 다 찼을 경우 자동으로 오래된 도큐먼트부터삭제한다. 제한하는 크기 값이 4096 보다 작거나 같으면 4096바이트가된다. 왜냐면 기본적으로 차지하는 크기가 있기 때문이다. 컬렉션의 크기는  4096보다 더 큰값을 넣으면 MongoDB는 받은 크기를 늘려  256 의 정수 배수로 만든다. 
Capped 컬렉션은 로그 데이터나 일정시간동안만 보관하는 통계데이터를 보관하고 싶을 때 유용하게 사용할 수 있다.

> 뷰

뷰는 미리 설정한 내용에 의해 뷰를 불러올 때마다실제로 데이터를 저장한 컬렉션으로부터 데이터를 모아서 데이터를 출력하게된다. 더정확한 이해를 위해 예를 들어 설명한다.

회원에 대한 컬렉션과 회원의 포인트에 대한 컬렉션이 각각 따로 있다고 가정해보자.그런데 내 애플리케이션의 많은 부분이 회원정보와 포인트에 대한 정보를 동시에 접근하게 된다면, 코드를 간결하게 유지하고 가독성을 높이기 위해 회원정보와 포인트를 한번에 불러올 수 있는 뷰를 만들어서 활용할 수 있다.

기존에 존재하던 데이터를 가공하여 마치 하나의 컬렉션인 것처럼 결과를 출력해준다. 이처럼 뷰는 실제로 데이터를 저장해서 불러오지 않기 때문에 사용할 수 있는 명령어에 제약이있다. 뷰를 생성하고 활용하기 위해서는 집계 파이프라인의 문법을 이용해야한다.

몽고 디비와 연결된 애플리케이션을 만들다 보면 컬렉션에 얼마나 많은 도큐먼트가 있는지 샤딩된 서버 또는 복제된 서버와의 연결은 잘되어있는지 데이터베이스가 에러가 난 상태인지 알아보아야할 상황이 발생하게된다. 

```js
db.getCollectionInfos()
db.serverStatus()
db.stats()
db.collection.isCapped()
db.collection.latencyStats()
db.collection.stats()
db.collection.storageSize()
db.collection.totalIndexSize()
db.collection.totalSize() // 컬렉션의 스토리지와 인덱스 크기의 합을 반환한다.
```

.find 명령어는 현재 들있는 모든 도큐먼트를 보여준다.
몽고 디비는 컬렉션 내부의 도큐먼트 뿐만아니라 컬렉션에 대한 정보도 함께 저장하기 때문에 실제 저장된 크기와 컬렉션의 크기 사이에는 오차가있다.


## 2.2 도큐먼트 생성

```js
use mydata

db.user.insertOne({username: "karoid", password: "1111"})
```

document 입력할 도큐먼트를 입력한다.
writeConcern 선택적 writeconcern 을 사용하려면 이 파라미터를 사용한다. id 필드에는 숫자나 문자 아무거나 넣어도되지만, 겹치면 안된다. 옵션값은 없어도 명령어가 기본적인 설정으로 작동하기 때문에 지금까지는 무시하면서 사용해왔지만 옵션도 살펴보자

> WreteConcern 

CRUD작업에 대한 명령어는 거의 대부분 WriteConcern 또는 ReadConcern옵션을 설정할 수 있다. 이 옵션은 insertOne 명령어가 도큐먼트를 컬렉션에 넣으려고 할 때 이미 컬렉션이 쓰기 작업을 하고있다면 어떤 영향을 줄지에 대한 것을 설정하는 옵션이다. 여기서의 쓰기 작업은 도큐먼트를 생성 , 수정, 삭제할 때를 말한다.

몽고디니븐 이런 작업을 성공적으로 마쳤다고 결과를 반환해도 실제로 장기저장장치에 바로 데이터를 저장하지 않고 메모리에 미리 저장한 후 천천히 장기 저장장치로 데이터를 옮긴다. 따라서 디비에 문제가 생기면 메모리에 담겨있는 데이터가 손실된다. 만약 데이버테이스가 복제가 되어있다면 이런 돌발상황에서 데이터의 손실이 일어날 수 있는 여지가 더있다. 데이터를 복사해가는 거울 서버에 데이터가 아직 업데이트 되지 않았는데, 정전과 같은 일로 원본 서버와의 연결이끊기면 거울서버가 원본 서버를 대신해 서비스가 연결된다. 이런 경우 미처 업데이트 하지 않은 정보가 사라지게된다. 
writeconcern 값은 이러한 데이터 손실이 일어나는 최악의 상황을 어느 정도 수준으로 막을 지 결정하게 돕는다. 물로 ㄴ저런 최악으 ㅣ상황으 ㄹ막기위해 설정값을 보수적으로 하면 비상상황에는 안정적이지만 일반적인 상황에서는 성능이 떨어지는 문제가 발생하게된다. 

insertOne 명령어를 실행하게 되면 반환값으로 명령을 실행한 결과를 알려준다. 

다수의 도큐먼트를 생성해보자

```js
db.collection.insertMany([문서1, 문서2, ....])
```

옵션의 필드에 새로 ordered 필드가 생겼는데, 순서대로 넣을지 순서대로 넣지 않을지 선택한다. 순서대로 넣지 않으면 샤딩된 데이터베이스의 경우 성능상의 이득을 볼수 있다.

> 원자성의 이해

몽고디비는 생성읽기 수정 삭제 작업에대해 원자성을 확보하고 있다. 쉽게말해 데이터베이스에는 작업이 완료된 상태가 되거나 완료되기 전 상태만 존재하지 그 중간 상태는 존재하지 않는다는 의미이다. 이게 어떤 의미인지그리고 왜 필요한지 알아보자.
몽고 디비 4.0버전 이상부터는 트랜잭션이라는 기능이 생겨서 이 명령어로 여러가지 작업에대한 원자성을 성립시킬수 있다. 

## 2.3 도큐먼트 조회

query , projection , documents (cursor) 데이터베이스 상의 도큐먼트의 커서

쿼리, db.containerBox.find({name: "가위"})

프로젝션은 각각의 도큐먼트의 어떤 필드를 노출할지 결정해주는 파라미터이다. 프로젝션을 이용해서 도큐먼트의 모든 필드를 불러오지 않고 원하는 필드만 가져오게 되면 불러오는 정보의 양을 줄어서 애플리케이션의 속도를 향상시킬  수 있다.
프로젝션 필드로 true 값만 설정하면 출력되는 도큐먼트 상에서 프로젝션 값을정하지 않은 필드는 전부 숨겨진다. 프로젝션 필드로 false 값만 설정하면 출력되는 도큐먼트 상에서 프로젝션 값을 정하지 않은 필드는 전부 나타난다. 만약 true 와 false  값이 둘 다있으면 에러가난다. 프로젝션에 명시하지 않은 필드를 숨길지 나타낼지 여부를 MongoDB가 정할 수 없기 때문이다.

"errmsg" : "Projection cannot have a mix of inclusion and exclusion"

정리하자면 프로젝션을 설정할 때 _id 필드를 제외한 필드들을 설정할 때 참또는 거짓이 두값중 하나만 존재하도록설정해야한다.

ReadConcern 앞서insertOne 와 insertMany 함수의 경우 옵션의 필드로 writeConcern 을 설정할 수 있었는데 find 함수는 읽기 작업을 하므로 ReadConcern 옵션을 설정하 ㄹ수 있다. ReadConcern 의 경우 복제 세트에서 더 정확한 값을 읽어 오기 위해 필요한 설정값이다. 

커서는 쿼리 결과에 대한 포인터다. find 명령어는 결과로 도큐먼트를 직접 반환하지 않고 커서를 반환한다. 더 나은 성능을 위해서이다. 포인터를 이용해서 해당 도큐먼트의 위치 정보만을 반환하여 작업을 효율적으로 만들 수 있다. 커서를 이용하면 데이터를 전부 불러올 도큐먼트만 선별적으로 조회를 할 수 있다. 또한 커서는 일시적으로 결과를 읽어내려고 존재하기 때문에 시간 제한 10분을 넘으면 비활상태로 전환된다. 커서를 보다 구체적으로 이해하기 위해코드를 보자

```js
var cursor= db.cappedCollection.find()
db.cappedcollection.find()

cursor.hasNext()
```

find 명령어를 실행하면 batch 라는 곳에 검색한 결과를 모아 놓는다. 상황별로 다르지만 일반적인 상황에서는 101개의 document를 batch에 모아놓고 20개씩 커서가 가리킨다. 다음 한개의 도큐먼트를 불러오기 위해서는 next()를 호출하면된다. 만약 커서로 batch 에 102번째 도큐먼트를 불러오려고 하면 batch 에 쿼리 결과를 102번째부터 시작해서 총 101개를 담고 102번째 도큐먼틀 커서가 가리키게된다. 이런방식을 이용하면 커서는 find 문의 모든 결과를 불러올 수 있다. 커서는 포인터기 때문에 커서를 이용해 도큐먼트를 가져올 메서드가 필요하다. 
<!-- 울어
울어울어울어썽 -->
<!-- 닐로 벗 -->
<!-- 모든순간을 꿈꾸게 하니까 언제나 너의곁에서 세상 그 누구보다 소중한~ 사람이 되고싶어 -->