데이터베이스를 어떻게 하면 효과적으로 다룰수 있는가 알아보자.

데이터베이스에서 데이터를 다루게 되면 하드웨어 개선 없이도 속도를 향상시키는 방법이있다. 그 가운데 대표적인 방법이 데이터 모델링과 데이터 인덱싱을 잘 하는 것이다.

## 6.1 컬렉션 사이의 관계

몽고 디비가 nosql이기 때문에 데이터의 구조에 대한 고민을 하지 않아도 된다고 여기는 경우가 종종 있다. 하지만 몽고디비도 기존의 관계형 데이터베이스와같이 데이터를 어떻게 구성할지 전략적으로 정하지 않으면 효율적인 데이터 처리를 수행하지 못한다. 이처럼 저장할 데이터의 구조를 정하는 작업을 데이터 모델링이라고한다. 데이터 모델링은 많은 양의 데이터를 빈번하게 조회하는 서비스에서 특히 중요하다. 


데이터 모델링 예시 다음은 만들고자하는 커뮤니티 서비스의 예시이다. 

1. 사용자는 이름과 생년월일, 점수를 가진다.
2. 게시판은 이름을 가진다.
3. 게시글은 사용자가 게시판에 작성가능하고 제목과 조회수를 표시한다. 
4. 조회수는 사용자당 1씩만 올릴 수 있고 다시 게시글을 읽어도 조회수가 오르지 않는다.

각각의 상자는 컬렉션을 의미하고 상자 안에 항목들은 컬렉션이 가지는 필드를 의미한다. 

게시판은 여러개의 게시글을 가질수 있고 게시글은 하나의 게시판에 속해있다.

사용자는 여러개의 게시글을 쓸 수 있고 게시글에는 한명의 글 쓴이가 있다.

사용자는 여러개의 게시글을 조회할수 있고 게시글은 여러명의 사용자가 조회할 수 있다.

사용자는 하나의 점수를 갖고 점수는 하나의 사용자를 갖는다.

> 일대 다 관계

컬렉션 사이의 관계를 설명하는 문장에서 게시판과 게시글의 관계를 한번 생각해보자. 
하나의 게시판에는 여러개의 게시글이 있고, 각각의 게시글은 하나의 게시판에 속해있어야한다. 이처럼 하나의 컬렉션이 다른 컬렉션에 속하는 관계를 일대다 관계라고한다. 일대다 관계를 의미하는 정보는 일반적으로 컬렉션에 속해지는 컬렉션 _id 값을 저장한다.

유일한 값으로 도큐먼트를 가리키는 방식을 레퍼런스 방식이라고한다. 두번째로 된 예시와 같이 다른 객체를 도큐먼트 내부에 포함시키는 방식을 레퍼런스 방식이라고한다. MongoDB에서 두 구조가 가지는 장단점이 명확하다.

> 다대다 관계

가시판과 게시글의 관계가 일대다 관계라면 예시에서 다른 종류의 관계로 어떤것이 있을까? 바로 사용자가 게시글을 조회할 때 사용자와 게시글의 관계가 다대다 관계이다. 사용자는 여러개의 글을 조회할 수 있고, 게시글은 여러 사람에게 조회될 수 있다. 두 컬렉션이 서로 다수의관계를 가지는 관계를 다대다관계라고 한다.

다대다 관계를 표현하기 위해서 조회 컬렉션을 만들고 게시글 컬렉션과 조회 컬렉션을 일대다 관계로 연결했고, 사용자 컬렉션과 조회 컬렉션을 일대다 관계로 연결했다. 이런 방법을 사용하면 게시글과 사용자 사이에 다대다 관계를 표현할수 있을까? 방법은 바로 한쪽 컬렉션 도큐먼트에서 다른 쪽 컬렉션 도큐먼트의 _id값을 배열로 가지고 있으면 된다.  이런 경우 조회 컬렉션없이 다대다 관계를 유지할 수 있다. 저장되는 데이터의 양이 줄어들고, 게시글을 읽어서 조회한 사용자를 불러올 때 정보 교환도 줄어든다. 하지만 한 사용자가 어떤 글을 읽었는지 확인하렴녀 모든 도큐먼트에 조회사용자 ids필드를 하나씩 검색해야한다. 결국 다대다관계에서 뱅려로 id 값을 저장하면 한방향으로는 정보 접근이 쉽지만 한방향으로는 정보 접근이 어려워지는 문제가 생긴다. 이런 문제점때문에 두 컬렉션 사이의 id값들을 서로 배열로 저장하는 방식도 있다. 이렇게 하면 양쪽 데이터로 접근할 때 더 편하지만 그만큼 데이터를 더 많이 저장해야하는 단점이 있다.

> 일대일 관계

두 컬렉션 사이에는 일대일 관계도 존재한다. 일대일 관계는 말 그대로 두개의 컬렉션이 서로 하나씩만 연결되어있는 관계이다. 일대일 관계를 연결하는 정보는 일대다 관계와 마찬가지로 상대방컬렉션 아이디값을 저장하면서 이루어진다. 일대일 관계는 저장하는 정보를 하나의 컬렉션으로 묶기에는 맞지 않으나, 성능을 향상 시키기 위해 두개의 컬렉션으로 나눠서 사용하게 된다. 컬렉션의 크기가 너무 커지거나 쓰기 작업이 빈번한 필드와 읽기 작업이 빈번한 필드를 나누고 싶을 땐 이런 형태를 가진 컬렉션을 만들게 된다. 일대일 관계에서 임베디드 방식은 그냥 한쪽을 다르 쪽에 임베디드하는 방식으로 만들수 있다.

## 6.2 레퍼런스방식과 임베디드 방식

컬렉션 사이의 관계를 살펴보면서 레퍼런스 방식과 임베디드 방식에 대해서 알아보자. 

레퍼런스 방식에서는 정보의 양이 늘어날수록 크기가 작은 도큐먼트의 개수가 늘어나게된다. 그리고 도큐먼트들 사이의 관계를 저장하기 위한 필드가 더 필요하다. 이제 새로운 정보를 추가하는 상황을 생각해보자. 임베디드 방식에서는 도큐먼트를 수정하여 정보를 추가하게된다. 반면 레퍼런스 방식에서는 도큐먼트 자체를 생성하여 컬렉션에 넣는다. 큰 차이가 아닌것 같지만 성능상의 차이점은 분명히 존재한다. 

도큐먼트의 크기가 커지면 어떤 장단점이있을까? 우선 장점부터살펴보자 몽고디비의 기본적인 도큐먼트 생성및 삭제 작업은 하나의 도큐먼트에 대해 원자성이 지켜진다. 따라서 다수의 게시글을 수정하면서 원자성을 지키기 쉽다 물론 이런 부분은 최근 몽고디비가 트랜잭션을 지원하면서 크게 장점으로 느껴지지않는다. 이제는 다수의 다큐먼트도 원자성을 보존할 수 있기 때문이다. 임베디드방식의 또다른 장점은 바로 임베디드된 내용을 읽는 것이 레퍼런스 방식에 비해 더 빠르다.
단여기서 주의해야할 점은 임베디드된 대부분의 정보를 읽어야하는 상황일 때 더 빠르다는 의미이다. 만약 임베디드된 내용중 일부분의 정보를 불러와야한다면 오히려 더 느릴 수 있다. 단순히 하나의 서버로 이루어져있다면 이 읽기 속도는 얼마 차이나지 않는다. 하지만 몽고디비가 샤딩되어있다면 속도차이가 더 날수 밖에없다. 이런 측면을 함께생각하면 빈번하게 함께 읽게되는 정보는 임베디드 방식으로 하나의 도큐먼트에 넣는 것이 바람직하다. 이제 임베디드 방식의 단점을 살펴보자 몽고디비의 도큐먼트 크기는 16mb로 제한되어있다. 이제한 때문에 임베디드 방식은 일부 상황에 적용하기 힘들다.만약 임베디드 되는 정보의 양이 한정적이라면 문제가 없지만 정보가 무한정 추가될 수 있다면 저앻지 ㄴ크기를 초과하는 문제가 생길것이다. 따라서 임베디드 방식이 레퍼런스 방식에 비해 하나의 도큐먼트에 저장할 정보량이 많아지면 성능상 불리하다.

도큐먼트의 크기가 클경우 많은 정보를 모두 램메모리에 읽어들인후 수정이 이루어지기 때문에 속도가 느려진다. 또한 복제가 이루어져있는 상황이라면 수정되는 도큐먼트 내의 모든 정보를 자신의 서버와 복제된 정보를 가져야하는 서버에 
보내기 때문에 특히 더 비효율적이다.

그렇다면 임베디드 방식을 언제 쓰는게 좋을까? 앞서 언급한 임베디드 방식의 단점을 살펴보면 도큐먼트의 크기가 과도하게 커지면 성능 저하가 일어날 확률이 높아진다. 특히 도큐먼트의 크기가 커졌을 때 그 도큐먼트를 수정하는 작업이 일어나면 별로 좋지않다.수정과 삭제 작업이 빈번하게 일어난다면 레퍼런스 방식이 좋다. 하지만 주로 읽기 작업이 이루어지고, 읽기 작업이 이루어질 때 정보들을 한꺼번에 불러올 경우가 많다면 임베디드 방식을 선택하는 것이 더 좋을 수 있다. 도큐먼트의 크기가 커지면 어떤 문제가 생기는 지 이해를 하고 있다면 이를 다른 문제에도 대입해 볼수 있다. 만약 레퍼런스 방식의 모델링을 했음에도 하나의 도큐먼트의 크기가 너무 크다면 일대일 관계로 해당 도큐먼트를 쪼개는 방법을 생각해볼 수 있다. 


## 6.3 인덱싱의 이해

익덱스를 한국어로 번역하면 색인이라는 의미를 지닌다. 데이터베이스에서 인덱스는 이와 비슷하게 데이터 속에서 중요한 부분을 표시해 놓아 쿼리 속도를 향상시키는 방법과 비슷하게 이해하면 좋다. 인덱스가 아처럼 실생활에도 적용되는 사례가 있기 때문에 일상생활의 비유를 통해 인덱스의 특징과 종류에 대해서 더 쉽게 이해할 수 있다. 

복합색인을 만들 때는 어떤 정보를 기준으로 먼저 묶을지가 중요하다. 특히 먼저 묶는 정보가 더 큰범위를 포괄하고 있을 수록 유용하다.

쿼리를 수행할 때 인덱스가 없다면 모든 도큐먼트를 일일이 조회해야한다. 인덱스는 쿼리 작업을 매우 효율적으로 만든다.

하지만 인덱스를 만들면 새로운 도큐먼트를 생성하거나 제거하는 작업을 빈번하게 할 때 속도의 저하가 발생한다. 매번 인덱스를 업데이트해야하기 때문이다. 단순 인덱스를 만들면 해당 필드만 조회할 때 사용하 ㄹ수 있고 다수의 필드를 대상으로 조회할 때에는 복합 인덱스가 필요하다.

복합 인덱스는 순서가 중요하다 a-b복합인덱스는  a 단순 인덱스와 같은 기능을 하기 때문에 대체할 수 있다. 몽고디비에서는 인덱스는 어떤 필드에 대한 값을 검색하기 쉽도록 그 필드의 값들을  B-Tree구조로 만들어서 저장한다.

마치 사람을 특정지어 부르기 위해 각각의 사람에 이름이 필요한 것처럼 도큐먼트들도 기본키를 항상 탑재하고 있다. _id 필드는 우리가 직접 인덱스를 생성하지 않아도 컬렉션이 생성될 때 자동으로 인덱스가 생성된다.  B-Tree 구조는 하나의 노드에 대해 두개이상의 자식노드를 가진다. 이 구주에서 몇가지 규칙이있는데, 가장 핵심적인 규칙만 소개하겠다. 우선 각각의 노드에 있는 키들은 전부 정렬되어있어야한다. 검색할 때 가장 적은 횟수의 조회를 하도록 정해진 규칙에 맞춰서 인덱스를 정리해야한다 .각각의 노드에키를 추가하기도하고 어떨 때는 노드를 쪼개거나 합치기도한다. 이런 과정을 균형 맞춤이라고한다. 앞선 신문 기사 수집의 비유에서 새로운 기사를 추가하거나 삭제하려면 이전보다 귀찮게 색인을 업데이트해야한다고 말했다. 인덱스도 마찬가지로 새로운 데이터를 추가하게되면 이런 균형맞춤작업을 해야하기 때문에 정말 필요한 인덱스가 아니면 함부로 생성하지 않는 것이좋고, 생성및 삭제작업이 빈번하다면 인덱스를 만들지 않는 것도 때로는 고려해봐야한다.

> 단일키 인덱스

한가지 종류의 인덱스 키값을 갖는 방식을 단일키 인덱스라고 부른다. 가장 대표적으로 id 필드의 값들을 키로 갖는 인덱스가 있다. 이방시의 인덱스를 사용하면 해당 필드에 어떤 값을 검색하거나 값의 범위에 해당하는 도큐먼트를 불러올 때 사용할 수 있다. 또한 도큐먼트를 해당 필드에 대해서 정렬할 때도 도움을 받을 수 있다.

> 복합키 인덱스

이처럼 여러가지 필드를 동시에 작업을 더 효율적으로 하기 위해서는 복합키 인덱스가 필요하다. 복합키 인덱스는 말 그대로 여러가지 필드의 값들을 키로 하는 인덱스이다. 복합키 인덱스는 두 필드의 값들을 어떻게 정렬해서 설정할지 정해주어야한다. 


> 다중키 인덱스

몽고디비는 배열 값에 대한 검색 상황을 대비해 배열에 대한 인덱스를 지원한다. 다중키 인덱스는 배열 속의 각각의 값을 인덱스 키로 저장한다. 그렇기 때문에 배열을 값으로 하는 필드에서 배열 소그이 어떤 값을 찾고자 할 때효율적인 검색이 가능하게 만들어준다.

텍스트 인덱스: 앞에서 살펴보았던 기본적인 인덱스는 값과 범위에 대한 검색을 최적화하고, 정렬할 때 활용할 수 있었다. 하지만 이런 방식의 인덱스는 문자열 검색에 있어서 한계점이 명확하다. 기사의 제목을 저장한다고 가정했을 때 기사의 제목이 완전하게 일치되게 검색하는 경우는 거의 없다. 대부분 기사에 포함된 단어 원형을 검색하는 것이 일반적이다. 이처럼 문자열을 검색하 ㄹ때는 정확하 ㄴ값을 검색하는 일은 거의없다. 범위 검색이나 정렬 기능도 그다지 쓸 일이 많지는 않다. 이와 같이 단어 단위 더 나아가 단어의 원형으로 검색하게 도와주는 인덱스가 바로 이 텍스트 인덱스이다. 영어의 경우 단어의 원형으로 인덱스를 생성하지만, 한국어의 경우 안타깝게도 형태소 분석 기능이 탑재되어있지않아서 그냥 단어 단위로 인덱싱하게 된다. 텍스트 인덱스는 하나의 컬렉션에 단 하나만 만들 수 있다. 

지리공간적 인덱스

> 해시 인덱스 

해시 인덱스에는 몇가지 제약이있다. 우선 해시 인덱스를 포함한 복합키 인덱스를 생성할 수 없다. 그러니까 해시 인덱스를 하나의 필드에 설정하면 복합적으로 다른 필드도 함께 설정할 수 없다. 또한 해시 인덱스는 배열을 값으로 가지는 필드에는 설정할 수 없다. 배열 자체를 모두 해시화해서 저장하기 때문이다. 

## 6.4 인덱스 명령어

인덱스 이름 정하기 

인덱스에 이름을 정할수 있다. 사실 인덱스의 이름을 정하지 않아도 몽고디비는 알아서 인덱스의 이름을 짓는다. 따라서 이름을 설정하는 것은 선택사항이다. 

TTL 인덱스

일정시간이 지나면 자도응로 도큐먼트를 삭제하도록 만들어준다. 바로 도큐먼트의 수명을 지정할수있는 것이다. 이 인덱스를 활용하면 시간에 따라 만료되는 문서나 로그데이터를 일정시간이 지나면 삭제하게 만들수 있다.

고유 인덱스

희소 인덱스

부분인덱스는 어떤상황에서 사용하는 것이 좋을까? 특정 필드값을 가지는 토큐먼트를 조회할 때만 인덱스를 활용하려고 할 때 사용하기 좋다. 특히 해당 컬렉션에 도큐먼트 추가 수정 삭제가 빈번해서 인덱스를 관리하는데 드는 비용을 최소화하고 싶다면 부분 인덱스의 사용을 고려해볼만하다.

