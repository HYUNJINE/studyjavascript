옛날 http , 리퀘스트를 보내고 리스폰스를 기다리는 그때의 웹은 http/1.1에 안주하지 않고 그 심플함을 유지하면서 새로운 기능을 요구하기 시작했다. HTTP라는 프로토콜을 이해하게되면 웹으 ㄹ깊이있게 이해할 숭 ㅣㅆ다. 




# 1장

## 1.1 웹은 HTTP로 나타낸다. 

서버에 의뢰하는 웹브라우저등을 클라이언트라고 한다. 이렇게 클라이언트에서 서버까지 일련의 흐름을 결정하고 있는 것을 웹에서 HTTP , HyperText Transfer protocol 이라고 부른다. 프로토콜이라는 의미는 약속이다. 즉 웹은 http라는 약속을 통한 통신이 이루어진다.

## 1.2 HTTP는 이렇게 태어났고 성장했다. 

HTTP의 등장배경을 알아보자.


### 1.2.1 웹은 지식 공유를 위해 고안되었다. 
CERN(유럽 입자 물리학 연구소)의 팀 버너스 리 박사는 멀리 떨어져있는 동료 연구자와 지식을 공유하게 할 수 있도록 시스템을 고안하였다. 최초로 고안한 것은 여러 문서를 상호간에 관련짓는 하이퍼텍스트에의해 상호간에 참조할 수 있는 World Wide Web, 의 기본 개념이 되는 것이었다. 이러한 WWW를 구성하는 기술로서 문서 기술로는 SGML을 베이스로한 HTML 문서 전송프로토콜로는  HTTP, 문서의 주소를 지정하는 방법으로 URL등 세가지가 제안되었다. WWW는 지금으로 말하자면 웹브라우저, 그 당시에는 하이퍼 텍스트를 열람할 수 있는 클라이언트 애플리케이션의 명칭이었다. 이것이 현재에는 이러한 일련의 시스템의 명칭으로 사용되어 WWW혹은 단순히 웹이라고 불리고 있다. 

### 1.2.2 웹이 성장한 시대

1990년 11월에 CERN에서 세계 최초의 웹서버와 웹브라우저가 개발되었다. 그로부터 3년뒤인 1993년에 대한민국 최초의 홈페이지가 개발되었다. 
http://cair.kaist.ac.kr

93년 1월에는 NCSA(미국 슈퍼 컴퓨터 응용 연구소 )에서 현재 사용하는 웹브라우저의 선조라고 말할 수 있는 모자이크를 개발했다. HTML의 이미지 표시를 인라인으로 처리하는 등 세련된 그래픽을 사용하여 세계에 널리 퍼졌다.

같은 해 가을에 윈도우 판과 매킨토시 판도 개발되었다. CGI를 사용할 수 있는 웹서버와 NCSA HTTPd1.0이 등장한 것도 이 무렵이다. 그 다음해인 94년 12월에 넷스케이프사에서 넷스케이프 내비게이터를 출시하고 95년에 마이크로소프트사에서 인터넷 익스플로러를 출시한다. 이무렵에 웹서버의 표준의 하나인 아파치고 아파치0.2로등장한다. HTML2.0도 발행되는등 웹이 약진하는 한단계가 되었다. 95년경부터 마이크로소프트사와 넷스케이프사에 의해서 브라우저 경쟁이 과열된다. 이 두회사는 독자적으로 HTML을 확장해 나갔기 때문에 지금도 HTM/l콘텐츠를 만드는 유저들으 곤란하게 만들고 있다. 

브라우저 벤더끼리 경쟁하면서 그당시 추진되었던 여러 웹 표준화를 모조리 무시한다. 새로운 기능에 대한 문서없는 상황이 종종 있었습니다. 

이러한 브라우저 경쟁은 넷스케이프사의 쇠퇴와 함께 2000년 경에 일단 결핍이난다. 그러나 2004년에 모질라 파이어폭스의 출시와 함께 제 2차 브라우저 전쟁에 돌입하게 된다. 인터넷 익스플로러는 버전 6에서 7이 등장하기까지 5년이 걸렸다. 그뒤로 8 9 10 버전을 연달아 출시한다. 또한 크롬과 오페라 사파리와 같은 브라우저도 점유율을 높이고 있다.

### 1.2.3 진보 안하는 HTTP

HTTP/0.9

http 가 등장한 때는 90년대인데 이당시 http 가 정식 사양서는 아니었다. 이당시 등장한 http는  1.0 이전이라는 의미에서 HTTP/0.9 로 불리고 있다.

HTTP/1.0

정식사양으로 공개된것은 96년 5우러이다. 이때 HTTP/1.0으로 RFC1945가 발행되었다. 초기의 사양이지만 현재에도 아직 많은 서버상에서 현역으로 가동되고있는 프로토콜 사양이다. 

HTTP/1.1
97년 1월에 공개된 HTTP/1.1 버전이 현재 가장 많이 사용되는 버전이다. 그 당시 사양이 RFC2068이지만 개정판으로 발행된 RFC2616이 최신 버전이다. 

## 1.3 네트워크의 기본은 TCP/IP

HTTP를 이해하기 위해서는 TCP/IP 프로토콜에 대해 어느정도 알고있어야한다.
인터넷을 포함하여 일반적으로 사용되고 있는 네트워크는 TCPIP라는 프로토콜에서 움직이고있다. HTTP는 그중 하나이다. 


### 1.3.1 TCPIP는 프로토콜의 집합

컴퓨터와 네트워크 기기가 상호간에 통신하기 위해서는 서로 같은 방법으로 통신하지 않으면 안된다. 예를 들면 어떻게 상대를 찾고 어떻게 상대에서 이야기를 시작하고 어떠한 언어로 이야기를 하며, 어떻게 이야기를 종료할까와 같은 규칙을 결정할 필요가 있다. 이렇게 서로다른 하드웨어와 운영체제를 가지고 서로통신을 하기 위해서는 모든 요소에 규칙이 필요하게 된다 이러한 규칙을 프로토콜이라고 부른다.

프로토콜에는 여러가지가 있다. 케이블 규격이랑 IP주소 지정 방법, 떨어진 상대를 찾기위한 방법과 그곳에 도달하는 순서 그리고 웹을 표시하기 위한 순서등이다. 

이렇게 인터넷과 관련된 프로토콜들을 모은것을 TCP/IP라고 부른다. TCP와 IP프로토콜을 가리켜 TCP/IP라고 부르기도 하지만, IP프로토콜을 사용한 통신에서 사요오디고 있는 프로토콜을 통칭해서 TCP/IP라는 이름이 사용되고 있다. 

### 1.3.2 계층으로 관리하는 TCP/IP

TCP/IP에서 중요한 개념중하나가 계층이다. TCP/IP는 애플리케이션 계층 트랜스포트 계층 네트워크 계층 링크 계층이렇게 4계층으로 나뉘어져있다. TCP/IP가 계층화된 것은 메리트가 있기 때문이다. 예를 들면 인터넷이 하나의 프로토콜로 되어있다면 어디선가 사양이 변경되었을 때 전체를 바꾸지 않으면 안되지만, 계층화 되어있으면 사양이 변겨오딘 해당 계층만 바꾸면 된다. 

계층화하면 설계를 편하게 할 수 있다. 애플리케이션층에서 애플리케이션은 자기 자신이 담당하는 부분을 고려하면되고, 상대가 어디에 있는지 어떠한 루트로 메시지를 전달하는지, 전달한 메시지가 확실하게 전달되고 있는지 같은 고려를 하지 않아도 된다. TCP/IP각 계층의 역할은 다음과 같다.

애플리케이션 계층

애플리케이션 계층은 유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정한다.
TCP/IP에는 여러 가지의 공통애플리케이션이 준비되어있다. 예를 들면 FTP랑 DNS등도 애플리케이션의 한가지이다. HTTP도 이계층에 포함된다.

트랜스포트 계층

애플리케이션 계층에 네트워크로 접속되어있는 2대의 컴퓨터 사이의 데이터 흐름을 제공한다. 트랜스포트 계층에서는 서로다른 성질을 가진 TCP transmission control protocol 와 UDP (User Data Protocol) 두가지가 있다. 

네트워크 계층 (혹은 인터넷 계층)

네트워크 계층은 네트워크상에서 패킷의 이동을 다룬다. 패킷아란 전송하는 데이터의 최소 단위이다. 이 계층에서는 어떠한 경로을 거쳐 상대의 컴퓨터까지 패킷을 보낼지를 결정하기도 한다. 인터넷의 경우라면 상대 컴퓨터에 도달하는 동안에 여러대의 컴퓨터랑 네트워크 기기를 거쳐서 상대방에게 배송된다. 그러한 여러가지 선택지 중에서 하나의 길을 결정하는 것이 네트워크 계층의 역할이다. 

링크 계층 (혹은 데이터 링크계층, 네트워크 인터페이스 계층)

네트워크에 접속하는하드웨어적인 면을 다룬다. 운영체제가 하드웨어를 제어하기 때문에 디바이스 드라이버랑 네트워크 인터페이스 카드 NIC를 포함한다. 그리고 케이블 등과 같이 물리적으로 보이는 부분도 포함한다. 하드웨어적 측면은 모두 링크 계층의 역할이다. 

### 1.3.3 TCP/IP 통신의 흐름



## 1.4 HTTP와 관계가 깊은 프로토콜은 IP/TCP/DNS

### 1.4.1 배송을 담당하는 IP

IP는 계층으로 말하자면 네트워크 층에 해당된다.

Internet Protocol 이라는 과장된이름이 지여져 있지만 실제 이름 그대로 인터넷을 활용하는 거의 대부분의 시스템이 IP를 이용하고 있다. IP는 TCP/IP라는 명칭의 일부가 될 정도로 중요한 프로토콜이다. IP와 IP주소를 혼동하는 사람이 있는데 IP는 프로토콜의 명칭이다.

IP의 역할은 개개의 패킷을 상대방에게 전달하는 것이다. 상대방에게 전달하기까지 여러가지 요소가 발생한다. 그중에서도 IP주소와 MAC주소라는 요소가 중요하다. IP주소는 각 노드에 부여된 주소를 가리키고 MAC주소는 각 네트워크 카드에 할당된 고유의 주소이다. IP주소는MAC주소와 결부된다. IP주소는 변경가능하지만 MAC주소는 변경불가.

통신은 ARP를 이용해서 MAC주소에서 한다. IP통신은 MAC주소에 의존해서 통신을 한다. 인터넷에서 통신 상대가 같은 랜선 내에 있을 경우는 적어서 여러대와 컴퓨터와 네트워크 기기를 중계해서 상대방에게 도착한다. 그렇게 중계하는 동안에는 다음으로 중계할 고스이 MAC주소를 사용하여 목적지를 찾아가는 것이다. 이때 ARP (Address REsolution Protocol)이 사용된다. ARP는 주소를 해결하기 위한 프로토콜중하나인데, 수신지의 IP주소를 바탕으로 MAC 주소를 조사할 수 있다. 

그 누구도 인터넷 전체를 파악하고 있지는 않다. 

목적지까지 중계를 하는 도중에 컴퓨터와라우터등의 네트워크 기기는 목적지에 도착하기 까지 대략적인 목적지만을 알고있다. 
이 시스템을 라우팅이라고 부르는데 택배 배송과 흡사하다. 화물을 보내는 사람은 택배 집배소에 화물을 가지고 가면 택배를 보낼수 있는 것만 알고 있으며 집배소는 화물을 보내고 보내는 곳을 보고 어느지역의 집배소에 보내면 되는지만 알고있다. 그리고 목적지에 있는 집배소는 어느 집에 배달하면 되는지만 알고있다. 결국 어떤 컴퓨터나 네트워크 기기도 인터넷 전체를 상세하게 파악하고 있지 못하다는 것이다.

### 1.4.2 신뢰성을 담당하는 TCP

TCP는 계층으로 말하자면 트랜스포트 층에 해당하는데 신뢰성있는 바이트 스트림 서비스를 제공한다. 바이트 스트림 서비스란 용량이 큰 데이터를 보내기 쉽게 TCP세그먼트라고 불리는 단위 패킷으로 작게 분해하여 관리하는 것을 말하고 신뢰성있는 서비스는 상대방에게 보내는 서비스를 의미한다. 결국 TCP는 대용량의 데이터를 보내기 쉽게 작게 분해해서 상대에게 보내고 정확하게 도착했는지 확인하는 역할을 담당하고있다. 상대에게 데이터를 확실하게 보내는 것이 일입니다. TCP는 쓰리웨이 핸드셰이킹이라는 방법을 사용한다. 이방법은 패킷을 보내고 나서 바로 끝이아니라 보내졌는지 여부를 상대에게 확인하러 간다. 이것은 SYN 와 ACK라는 TCP플래그를 사용한다. 송신측에서는 SYN플래그로 상대에게 접속함과 동시에 패킷을 보내고 수신측에서는 SYN/ACK플래그로 송신측에 접속함과 동시에 패킷을 수신한 사실을 전달한다. 마지막으로 송신측이 ACK플래그를 보내 패킷교환이 완료되었음을 전한다. 
이 과정에서 어디선가 통신이 도중에 끊어지면 TCP는 그와 동시에 같은 수준으로 패킷을 재전송한다. 

## 1.5 이름 해결을 담당하는 DNS

Domain Name System 은 http 와 같이 응용계층 시스템에서 도메인 이름과 IP주소 이름 확인을 제공한다. 컴퓨터는 ip 주소와는 별도로 호스트이름과 도메인 이름을 붙일 수 있다. 

## 1.6 각각과 http와의 관계

## 1.7 URL 과 URI

URI 보다 URL 이 익숙하지 않은가? 웹 브라우저 등으로 웹 페이지를 표시하기 위해 입력하는 주소가 바로 URL 이다. 

### 1.7.1 URI는 리소스 식별자

Uniform Resource Identifiers 의 약자이지만 RFC2396 에는 다음과 같이 정의된다. 

Uniform 

통일된 서식을 결정하는 것으로 여러가지 종류의 리소스 지정 방법을 같은 맥락에서 구별없이 취급할수 있게 한다. 또한 새로운 스키마 도입을 용이하게 한다. 

Resource 

리소스는 식별 가능한 모든것이라고 정의된다. 도큐먼트 파일뿐만아니라 이미지와 서비스 등 다른 것과 구별할 수 있는 것은 모두 리소스이다. 또한 리소스는 단일한 부분만 아니라 복수의 집합도 리소스로 파악할 수 있다. 

Identifier 

식별 가능한 것을 참조하는 오브젝트이며 식별자로 불린다. 결국 URI는 스키마를 나타내는 리소스를 식별하기 위한 식별자이다. 스키마는 리소스를 얻기위한 수단에 이름을 붙이는 방법이다. http의경우에는 http를 사용한다. 그 외에도ftp와 mailto, telnet, file등이 있다. 공식 URI싀마는 인터넷 상의 자원 관리등을 하는 비영리 법인 ICANN 산하 조직인 LANA에 등록되어있으며 30개 정도 있다. 

URI는 리소스를 식별하기 위해 문자열 전반을 나타내는데 비해 URL은 리소스의 장소를 나타낸다. URL은 URI의 서브셋이다. 

RFC 3986: Uniform Resource Identifier : Generic Syntax 에 적혀있는 URI예로서 다음과 같은 것이있다. 

### 1.7.2 URL 포맷

URI는 필요한 정보 전체를 지정하는 완전 수식 절대 URI혹은 완전수식 절대 URL과 브라우저 중의 기준 URI에서 상대적 위치를 */image/log.gif 와 같이 지정하는 상대 URL 이 있다. 

http와 https 와 같은 스키마를 사용하여 리소스를 얻기 위해 사용하는 프로토콜을 지시한다. 대문자와 소문자는 무시되고 마지막에 콜론이 하나 붙는다. 

- 서버주소: 완전 수식 형식인 URI에서는 서버주소를 지정할 필요가없다. 
- 서버 포트: 서버의 접속 대상이 되는 네트워크 포트 번호를 지정한다. 이것은 옵션이며 생략한면 디폴트 포트가 사용된다.
- 계층적 파일 패스: 특정 리소스를 식별하기 위해서 서버상의 파일패스를 지정한다 . UNIX 디렉토리 지정 방법과 비슷하다.
- 쿼리 문자열: 파일 패스로 지정된 리소스에 임의의 파라미터를 넘겨주기 위해 쿼리 문자열을 사용한다. 이것은 옵션이다. 
- 프레크먼트 식별자: 주로 취득한 리소스에서 서브 리소스를 가리키기위해 프레크멘트 식별자가 사요오딘다. 


실제 사양대로 되지 않을 수도 있다.

HTTP기술 사양으 ㄹ정한 몇가지 RFC(Request for Comments) 문서가 있는데 보통 RFC 사양에 정해져있는 내용을 애플리케이션에 구현할 경우 사양대로 구현한다. 인터넷 설계서인 RFC에 기술된 대로 만들지 않으면 통신할 수 없는 상황에 빠질 수 있기 때문이다. 예를 들어 RFC 대로 만들지 않은 웹서버가 있다면 웹브라우저에서 접근하지 못할 수 있다.

RFC 대로 만들지 않고서는 HTTP를 사용한 통신을 할 수 없으므로 기본적으로 HTTP를 사용하는 클라이언트나 서버는 RFC를 따른다. 하지만 일부 클라이언트나 서버에서는 RFC에 따르지 않는 사양도 있고 더나아가 독자적으로 확장하는 경우도 있다.

RFC에 따르지 않는다면 구태여 독자적인 사양에 다른 모든 클라이언트나 서버를 당연히 맞출 필요가 없다. 하지만 그 애플리케이션의 점유율이 크다고 한다면 어떻게 될까. 만약 점유율이 큰 애플리케이션이라면 다른 쪽이 필연적으로 맞출 수 밖에 없다.

실제로 인터넷에서 사용되는 HTTP를 사용하는 서버나 클라이언트중에는 이러한 예가 있다. 이 책에서 소개한 HTTP동작과는 다른 부분도 있으니 사용방법의 차이가 있을 수 있다.