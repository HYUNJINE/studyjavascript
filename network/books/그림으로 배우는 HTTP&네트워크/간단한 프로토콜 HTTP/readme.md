## 2.1 HTTP는 클라이언트와 서버간에 통신을 한다.

TCP/IP에 있는 다른 많은 프로토콜과 마찬가지로 HTTP도 클라이언트와 서버간에 통신을 한다. 텍스트와 이미지등과 같은 리소스를 필요하다고 요구하는 쪽이 클라이언트가 되고 이러한 리소스를 제공하는 쪽이 서버가된다.

HTTP는 클라이언트와 서버의 역할을 명확하게 구별하고 있다.

## 2.2 리퀘스트와 리스폰스를 교환하여 성립

HTTP는 클라이언트ㄹ로부터 리퀘스트가 송신되며, 그결과가 서버로부터 리스폰스로 되돌아온다. 즉 반드시 클라이언트 측으로 부터 통신이 시작된다. 서버측은 리퀘스트를 받지 않고서는 리스폰스를 송신하는 일은 없다. 서버측은 리퀘스트를 수신하지 않으면 리스폰스가 발생하는 경우는 없다. 

리퀘스트를 받은 서버는 리스폰스를 클라이언트에게 되돌려준다.

HTTP /1.1 200 OK
Date: Tue, 10 Jul 2012 06:60:15 GMT

서버의 HTTP버전과 200는 리퀘스트의 처리 결과를 나타내는 상태 코드와 설명이다. 다음 줄은 리스폰스가 발생한 일시를 나타내고 있는데 헤더필드라고 불리는 것중하나이다.

## 2.3 HTTP는 상태를 유지하지 않는 프로토콜

HTTP는 상태를 유지하지않는 stateless 프로토콜이다. HTTP프로토콜 독자적으로 리퀘스트와 리스폰스를 교환하는동안에 상태를 관리하지 않는다. 결국 HTTP프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않는다. HTTP에서는 새로운 리퀘스트가 보내질 때마다 새로운 리스폰스가 생성된다. 프로토콜로서는 과거의 리퀘스트와 리스폰스를 가지지않는다. 이는 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성(scalability)를 확보하기 위해서 이와 같이 간단하게 설계되어있는 것이다.

그러나 웹이 진화함에따라 스테이트리스 특성만으로는 처리하기 힘든 일이 증가하게된다. 예를 들면 쇼핑 사이트에 로그인했을 때이다. 다른 페이지로 이동해도 로그인 상태를 유지할 필요가 있다. 이를 위해서는 누가 어떤 리퀘스트를 보냈는지 파악하지 위해 상태유지 필요가생겼고, 쿠키기술이 도입된다. 쿠키로 인해 HTTP를  이용한 통신에서도 상태를 계속 관리할 수 있게 되었다.


## 2.4 리퀘스트 URI로 리소스를 식별

HTTP는 URI를 사용하여 인터넷상의 리소스를 지정한다. 이 URI가 있는 덕분에 인터넷 상의 어떤 장소에 있는 리소스도 호출할 수 있다. 특정 리소스가 아닌 서버 자신에게 리퀘스트를 송신하는 경우에는리퀘스트 URI에  *를 지정할 수 있다. 아래는 HTTP서버가 지원하고 있는 메소드를 묻는 예이다.

`OPTIONS * HTTP/1.1`



## 2.7 지속 연결로 접속량을 절약

HTTP초기 버전에서는 HTTP통신을 한번 할때마다 TCP에 의해 연결 종료를 할 필요가 있었다.

초기 당시의 통신에서는 작은 사이즈의 텍스트를 보내는 정도 였기 때문에 이렇게 기능을 구현해도 문제는 없었다. 그러나 HTTP가 널리 보급되어감에따라 다량의 이미지를 포함한 문서등이 늘어났다. 

### 2.7.1 지속 연결

HTTP/1.1와 일부 HTTP/1.0에서는 TCP연결 문제를 해결하기 위해 지속연결이라는 방법을 고안한다. persistent connections . 지속 연결의 특징은 어느 한쪽이 명시적으로 연결을 종료하지 않는이상 TCP연결을 계속 유지한다. 

지속연결을 하는 이점은 TCP커넥션의 연겨로가 종료를 반복하는 오버헤드를 줄여주기 때문에 서버에대한 부하가 줄어든다. 또한 오버헤드를 줄인 만큼 HTTP리퀘스트와 리스폰스가 빠르게 완료되기 때문에 웹페이지를 빨리 표시할 수 있다.

이러한 지속연결은 HTTP/1.1 에서는 표준 동작이지만 이전버전에서는 정식사양이 아니었다. 일부 서버에서는 사양에 없는 기능을 구현해서 지속연결이 가능하게 한 것도 있지만 반드시 지속연결이 지원되고 있다고는 할 수없다. 물론 클라이언트도 지속 연결을 지원할 필요가 있다. 

### 2.7.2 파이프라인화 

지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이트라인화를 가능하게 한다. 파이프라인화에 의해서, 이전에는리퀘스트 송신후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행하던 것을 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다. 이로인해 여러리퀘스트를 병행해서 보내는 것이 가능하기 때문에 일일이 리스폰스를 기다릴 필요가 없다.

예를 들면 html 한페이지에 10개의 이미지를 포함한 웹페이지를 리퀘스트한경우에는 개별 연결보다 지속 연결이 리퀘스트 완료가 빠르고 게다가 지속연결보다 파이프라인화쪽이 빠르다. 이 차이는 리퀘스트 수가 늘어날 수록 현저하게 나타난다. 

## 2.8 쿠키를 이용한 상태관리

상태를 유지하지 않는다는 점에서 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있다. 또한, 단순한 프로토콜이기에 HTTP가 다양한 곳에서 이용되는 측면도 있다.

스테이트리스 프로토콜이라는 특징은 남겨둔채 이와 같은 문제를 해결하기 위해 쿠키라는 시스템이 도입된다. 쿠키는 리퀘스트와 리스폰스에 쿠키정보를 추가해서 클라이언트의 상태를 파악하기 위한 시ㅡㅅ템이다. 쿠키는 서버에서 리스폰스로 보내진 Set-Cookie 라는 헤더필드에 의해 쿠키를 클라이언트에 보존하게된다. 다음번에 클라이언트가 같은 서버로 리퀘스트를 보낼때 쿠키값을넣어서 전송한다. 서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접소갷ㅆ는지 체크하고 서버상의 기록을 확인해서 이전 상태를 알 수 있다.

