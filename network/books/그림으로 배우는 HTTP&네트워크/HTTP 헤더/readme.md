## 6.1 HTTP 메시지 헤더

HTTP프로토콜의 리퀘스트나 리스폰스에는 반드시 메시지 헤더가 포함되어있는데 메시지 헤더에는 클라이언트나 서버가 리퀘스트나 리스폰스를 처리하기 위한 정보가 들어있다. 이러한 정보의 대부분은 클라이언트를 이용하는 사용자가 직접 볼 필요는 없다. 메시지헤더는 몇가지의 요소로 구성되어있다.

- 리퀘스트의 HTTP 메시지: method, URI , HTTP version , HTTP header 필드 등으로 구성되어있다.

리스폰스의 HTTP메시지: http 메시지와 HTTP버전, 상태코드, HTTP헤더 필드등으로 구성

## 6.2 HTTP헤더필드

### 6.2.1 http 헤더 필드는 중요한 정보를 전달한다.
헤더 필드는 HTTP메시지를 구성하는 요소의 하나이다. 헤더 필드는 http프로토콜 중에서 클라이언트와 서버간의 통신에서 리퀘스트에도 리스폰스에도 사용되고 있고 부가적으로 중요한 정보를 전달하는 역할을 담당하고 있다. 그리고 메시지 바디의 크기나 사용하고있는 언어인증 정보등을 브라우저나 서버에 제공하기 위해 사용되고 있다.

### 6.2.2 HTTP헤더 필드의 구조

HTTP 헤더 필드는 헤더 필드명과 필드값으로 구성되어있고 콜론으로나뉘어져있다.
예를 들면, 메시지 바디의 오브젝트의 타입을 가리키는 Content-Type 이라는 HTTP헤더 필드가 포함되어있다. Content-Type:text/html

HTTP헤더필드가 중복된경우는? -> 사양으로 정해져있기 떄문에 브라우저에따라 다른 동작을 한다.어떤 브라우저는 최초의 헤더 필드를 우선적으로 처리하고 어떤 브라우저는 마지막 헤더필드를 우선적으로 처리한다.

### 6.2.3 4종류의 HTTP헤더 필드

HTTP 헤더 필드는 그 용도에 따라 다음과 같이 4종류로 분류된다.

- 일반적 헤더필드(General Header Fields) 리퀘스트 메시지와 리스폰스 메시지 둘다 사용되는 헤더이다.
- 리퀘스트 헤더 필드 (Request Header Fields): 클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더로 리퀘스트의 부가적 정보와 클라이언트의 정보, 리스폰스의 콘텐츠에 관한 우선순위 등을 부가한다.
- 리스폰스 헤더필드: 서버측에서 클라이언트 측으로 송신한 리스폰스 메시지에 사요오디는 헤더로 리스폰스의 정보와 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가합니다.
- 엔티티 헤더필드(Entity Header Fields): 리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더로 콘텐츠 갱신 시간 등의 엔티티에 관한 정보를 부가한다.


### 6.2.4 HTTP/1.1 헤더 필드 일람

HTTP/1.1 에 정의되어 있는 헤더 필드에는 47 종류가 있다.
- Cache-Control: 캐싱 동작 지정
- Connection: Hop-by-hop 헤더, 커넥션 관리
- Date: 메시지 생성 날짜
- Pragma : 메시지 제어
- Trailer: 메시지 끝에 있는 헤더의 일람
- Transfer-Encoding: 메시지 바디의 전송 코딩 형식 지정
- Upgrade: 다른 프로토콜에 업그레이드
- Via: 프록시 서버에 관한 정보
- Warning: 에러 통지
- Accept: 유저 에이전트가 처리가능한 미디어 타입
- Accept-Charset: 문자셋 우선 순위
- Accept-Encoding: 콘텐츠 인코딩 우선순위
- Accept-Language: 언어 우선순위
- Authorization: 웹 인증을 위한 정보
- Except: 서버에 대한 특정 동작의 기대
- From: 유저의 메일 주소
- Host: 요구된 리소스의 호스트
- if-Match : 엔티티 태그의 비교
- if-Modified-Since: 리소스의 갱신 시간 비교
- if-Range: 리소스가 갱신되지 않은 경우에 엔티티의 바이트 범위의 요구를 송신
- if-Unmodified-Since: 리소스의 갱신시간 비교
- Max-Forwards: 최대 전송 홉수
- Proxy-Authorization: 프록시 서버의 클라이언트 인증을 위한정보
- Range: 엔티티의 바이트 범위 요구
- Referer: 리퀘스트중의 URI를 취득하는 곳
- TE: 전송 인코딩의 우선순위
- User-Agent: HTTP클라이언트의 정보
- Accept-Ranges: 바이트 단위의 요구를 수신할 수 있는지의 여부
- Age: 리소스의 지정 경과시간
- Etag 리소스특정하기 위한 정보
- Location: 클라이언트를 지정한 URI에 리다이렉트
- Proxy-Authenticate : 프록시 서버의 클라이언트 인증을 위한 정보
- Retry-After : 리퀘스트 재시행의 타이밍 요구
- Server: HTTP서버 정보
- Vary: 프록시 서버에대한 캐시관리정보
- WWW-Authenticate: 서버의 클라이언트 인증을 위한 정보

- Allow: 리소스가 제공하는 HTTP메소드
- Content-Encoding: 엔티티 바디에 적용되는 콘텐츠 인코딩
- Content-Language: 엔티티의 자연어
- Content-Length: 엔티티 바디의 사이즈(단위: 바이트)
- Content-Location: 리소스에 대응하는 대체 URI
- Content-MD5: 엔티티 바디의 메시지 다이제스트
- Content-Range: 엔티티 바디의 범위 위치
- Content-Type: 엔티티 바디의 미디어타입
- Expires: 엔티티 바디의유효기간 날짜
- Last-Modified: 리소스의 초종 갱신 날짜

### 6.2.5 HTTP/1.1 이외의 헤더 필드
HTTP에서 교환되는 HTTP 헤더필드가 RFC2616에서 정의된 47종류만 있는 것은 아니다. 예를들면, Set-Cookie, Content-Disposition 과 같이 정의외에 폭넓게 사용하는 것도있다.

### 6.2.6 End-to-end 헤더와 Hop-by-hop 헤더

HTTP 헤더필드는 캐시와 비캐시 프로깃의 동작을 정의하기 위해서 두가지 카테고리로 분류되어있다.

엔드투엔드는 리퀘스트나 리스폰스의 최종 수신자에게 전송된다. 캐시에서 구축된 리스폰스중 보존되야하고 다시 전송되지 않으면 안되도록 되어있다.

hop-by-hop 은 한번 전송에 대해서만 유효하고 캐시와프록시에의해서 전송되지 않는 것도있다. HTTP/1.1 에서 홉바이홉헤더에는 다음과 같은 것이있다. 여기서 열거하는 8개의 헤더필드 이외에는 모두 엔드투엔드 헤더에 분류된다.

- Connection
- Keep-Alive
- Proxy-Authenticate
- Proxy-Authorization
- Trailer
- TE
- Transfer-Encoding
- Upgrade

## 6.3 HTTP/1.1 일반 헤더 필드

캐시 컨트롤 헤더는 디렉티브로 불리는 명령을 사용하여 캐싱 동작을 지정한다. 지정한 디렉티브에는 파라미터가 있는 것도 없는것도 있으며 여러개의 디렉티브를 지정하는 경우에는 콤마로 구분한다. Cache-Control 헤더 필드 디렉티브는 리퀘스트 및 리스폰스할 때에 사용가능 private 디렉티브가 사용되는 경우 리스폰스는 특정 유저만을 대상으로 하고있는것을 나타낸다. public 디렉티브와 기능이 반대이다.
캐시 서버는 특정 유저를 위해서 리소스를 캐시할 수 있지만 다른 유저로부터 같은 리퀘스트가 온다고 하더라도 그 캐시를 반환하지 않도록 한다.

클라이언트의 리퀘스트로 no-cache 디렉티브가 전송된 경우 캐시된 리스폰스를 클라이언트가 받아 들이지 않음을 나타낸다. 즉 중간 ㅐ시서버가 오리진 서버까지 리퀘스트를 전송해야한다.

서버의 리스폰스에  no-cache 디렉티브가 사용된 경우, 캐시 서버는 리소스를 저장할 수 없다. 오리진 서버는 캐시서버가 이후의 리퀘스트에서 리소스의 유효성을 재확인하지 않고는 그 리스폰스를 사용하지 못하도록 한다.
서버의 리스폰스로 no-cache의 필드 값에 헤더 필드명이 지정된 경우에는 이 지정된 헤더 필드만 캐시할 수 없다. 즉 지정된 헤더 필드 이외에는 캐시가 가능하다. 이파라미터는 리스폰스 디렉티브만 사용가능하다. no-store 디렉티브가 사용된경우 리퀘스트와 혹은 리스폰스에 기밀정보가 포함되어있음을 나타낸다. 그렇기 때문에 캐시는 리퀘스트리스폰스의 일부분을 로컬 스토리지에 보존해서는 안되도록 지정한다. 