# PostgreSQL

## PostgreSQL이 무엇인가?

PostgreSQL은 객체 관계형 데이터베이스 관리 시스템(ORDBMS)이다. 이것은 미국 캘리포니아에 있는 버클리 대학 컴퓨터 과학부에서 개발한 POSTGRES, Version4.2를 기반으로 개발되었다.

PostgreSQL은 원래의 버클리 소스를 기반으로 확장된 오픈 소스이다. 이것은 표준 SQL 기능을 대부분 지원하며, 다음과 같은 진보된 많은 기능도 함께 지원한다.

- 복합 쿼리
- 참조키
- 트리거
- 업데이트 가능한 뷰
- 트랜잭션
- 다중 버전 병행 제어

  또한, PostgreSQL에서는 다양한 방법으로 기능을 확장 할 수 있다. 예로, 다음과 같은 것들을 사용자가 직접 새로 만들 수 있다.

- 자료형
- 함수
- 연산자
- 집계 함수
- 인덱스 방법
- 프로시져 언어

그리고, PostgreSQL의 라이센스는 개인적이든, 상업적이든, 교육용이든 어떠한 목적으로도 누구가나, 소스를 수정하고, 재배포 할 수 있다.

## PostgreSQL 설치

대부분의 시스템에는 이미 PostgreSQL패키지가 설치되어있는 경우가 많다. OS의 배포판에 기본으로 내장되고, 특별히 제외시키지 않는다면, 기본적으로 설치되어있기 때문이다. 이런 경우라면, OS배포판 설치문서나 안내문서를 참조하면 PostgreSQL 패키지가 어디에 설치되어있고, 어떻게 사용한는지 알 수 있다.

## 기본 구조

데이터 베이스 전문용어로, PostgreSQL은 클라이언트/서버 모델을 사용하고 있다. 하나의 PostgreSQL세션(작업)은 다음과 같은 프로세스들 (프로그램들)의 상호 작동으로 구성된다.

- 서버 프로세스, 이것은 데이터베이스 파일을 관리하고, 클라이언트 응용 프로그램들이 서버에 연결을 요청할 때, 이 요청들을 처리(수락하거나 거부하는 일)하고, 클라이언트들이 데이터베이스를 사용할 수 있도록 기반 작업들을 준비한다. 이 프로세스의 이름은 postgres이다.
- 클라이언트 프로세스, 이것은 데이터베이스를 사용하려는 사용자 측 응용 프로그램을 말한다. 클라이언트 응용 프로그램은 자연적으로 매우 다양한 형태를 띄고 있다. 어떤 것은 텍스트 기반의 프로그램이기도하고, 어떤것은 그래픽응용 프로그램이기도하고, 어떤 것은 웹서버를 통해서 웹페이지로 보여지기도 한다. 몇 클라이언트 프로그램들은 이미 PostgreSQL 패키지 안에 포함되어서 배포되기도 한다. 이것들은 대부분 사용자들이 직접 개발한 것들이다.

클라이언트/서버 환경의 프로그램들은 대부분이 그렇듯이, PostgreSQL에서도 클라이언트와 서버가 서로 다른 호스트일 수 있다. 이런 경우에는 서로가느이 통신이 TCP/IP 네트워크 기반에서 이루워진다. 클라이언트와 서버가 서로 틀릴 경우에는 클라이언트에서 접근하고자 하는 데이터베이스 파일에 대해서 직접적으로 접근 할 수 없음을 의미한다. 즉, 클라이언트에서 접근 할 수 있는 파일은 그 클라이언트가 실행되고 있는 호스트의 파일이지 서버가 가동중인 호스트의 파일이 아님을 알고 있어야한다.

PostgreSQL서버는 사용자의 다중 접속을 위해서 각 접속에 대해서 새로운 프로세스를 할당한다.(전문용어로 "forks"를 이용한 하위 프로세스 생성이라고도 한다.) 이 방법으로 클라이언트와 새로 만들어진 서버 프로세스간의 작업이 있을 때, 서버의 상위 프로세스 격인 postgres프로세스의 간섭 없이 작업이 이루워짐을 의미한다. 종합하면, postgres프로세스는 서버 호스트에서 항상 실행되고 있으면서, 클라이언트의 접속 요청을 처리해서 새로운 하위 서버 프로세스를 만드는 역할을 한다. 물론 이 모든 작업들은 사용자가 관심을 가지고 살펴보지 않는 이상 서버 차원에서 자동으로 이루워지는 부분이다.

## 데이터 베이스 만들기

각각의 사용자 단위나, 프로젝트 단위로 데이터베이스를 분리해서 작업하는 것이 일반적이기에, 하나의 PostgreSQL 서버는 많은 데이터베이스를 관리 할 수 있다.
어쩌면, 이미 시스템 관리자가 일반 사용자들을 위해서 그들이 사용할 수 있는 데이터베이스를 미리 만들어 두었을 수도 있다. 이런 경우라면, 시스템 관리자가 일반사용자들에게 그 사실을 알려서 사용할 수 있는 데이터베이스 이름을 알려주어야한다.
데이터 베이스 이름은 아무거나 해도된다. PostgreSQL에서는 만들수 있는 데이터베이스 개수 제한이 없다. 하지만 데이터베이스 이름은 첫글자가 영문 알파벳이어야하면 길이는 최대 63바이트까지이다. 데이터베이스 이름으로 가장 편하게 사용할 수 있는 이름은 그 데이터베이스를 만드는 사용자의 이름과 같은 것이다. 왜냐하면 많은 프로그램들이 이 사용자와 같은 이름의 데이터베이스 이름을 그 사용자의 기본 데이터베이스로 가정하기 때문이다.이런식으로 사용자의 이름과 같은 데이터베이스를 만드려면, 아래와 같은 명령을 이용하면 된다.

```code
createdb
```

만든 데이터를 더 이상 사용할 일이 없으면, 데이터베이스를 삭제 할 수 있다. 예를 들어서 mydb 데이터베이스를 만든 사람이 그 데이터베이스를 삭제하려면, 다음과 같은 명령을 이용한다.

```code
dropdb mydb
```

dropdb명령은 그 인자가 없어도 기본으로 삭제할 데이터베이스를 사용자 이름과 같은 데이터베이스를 삭제하지는 않는다. 반드시 삭제할 데이터베이스 이름을 지정해 주어야한다. 이 작업은 해당 데이터베이스와 관련된 모든 파일들을 물리적으로 완전히 삭제하는 것이다. 그러기에 실행 취소를 할 수 없다.이 작업을 할때는 신중히 해야한다.

PostgreSQL서버의 사용자와 시스템 사용자는 엄격히 다르다. 구체적으로 말하자면, 데이터베이스를 만들거나 사용할 수 있는 사용자가 꼭 시스템 사용자로 존재해야하는 것도 아니며, 특정 시스템 사용자가 반드시 PostgreSQL서버의 사용자로 존재해야할 이유도 없다. 단지 PostgreSQL 프로그램들은 해당 데이터베이스를 사용하기 위한 사용자를 지정할 때, 기본적으로 현재 사용중인 시스템 사용자의 이름을 이용한다. 만일 사용자가 없다거나, 해당 사용자의 권한이 부당한 오류 메시지를 만난다면, 그것은 데이터베이스의 사용자에 대한 이야기이다.

## 데이터베이스 사용하기

- psql 이라는 명령어로 PostgreSQL대화형 터미널 프로그램을 실행하기. 이것은 대화형으로 SQL명령을 편집/실행할 수 있다.
- pgAdmin와 같은 그래픽 툴을 이용하거나 ODBC나 JDBC를 이용한 다른 툴들로 데이터베이스를 만들거나 사용할 수 있다.
- 직접응용프로그램을 만들어서 사용하기. PostgreSQL에서는 이런 응용프로그램을 만들 수 있는 다양한 프로그램 언어를 지원한다.

```code
psql mydb
```

데이터 베이스 이름이 빠지면 기본적으로 현재 시스템 사용자 이름과동일한 이름의 데이터베이스에 접속을 시도한다.

서버를 실행한 시스템 사용자 이름과 데이터베이스 사용자이름이 같은 경우 대부분 아래와 같이 보인다.

```code
mydb=#
```

psql프로그램에는 SQL명령 말고도 내부적으로 사용 할 수 있는 명령들이 있다. 이 명령들을 psql 내장 명령어라고 한다. 이 명령들은 역슬래쉬 문자로 시작한다. 예를 들어서 PostgreSQL의 SQL구문을 살펴보자

```code
mydb=> \h
```

psql을 마치려면:

```code
mydb=> \q
```

이 명령이 실행되면, psql프로그램은 종료되고 다시 시스템 쉘 명령 프롬프트가 나타난다.

## SQL언어

psql 프로그램을 실행할 때 -s옵션을 사용하면 SQL명령어들을 하나씩 확인하면서 실행할 수 있다.
PostgreSQL은 관계형 데이터베이스 관리시스템이다. 이 말은 관계들로 구성된 자료를 관리하기위한 시스템이라는 뜻이다. (RDBMS)
이 관꼐라는 용어는 원래 수학용어였는데, 이것이 RDBMS에서는 테이블 사이의 수학적 관계를 설명하는데 이용되었고, 결국 관계형 데이터베이스라는 용어로 사용되었다. 자료를 테이블로 저장하는 방식은 오늘날 너무도 당연한 것으로 인식되고있다. 하지만 이것은 단지, 데이터베이스를 구현하는 여러가지 방법 가운데 하나일 뿐이다. 유닉스 계열 운영체제에서 사용되는 파일과 디렉터리 개념은 계층형 데이터베이스를 구현하는 한 예이다. 또한 최근에는 객체지향 개념을 이용해서 데이터베이스를 구현한다. 각각의 테이블은 로우라고 불리는 것들의 집합이다. 테이블을 구성하는 그 각각의 로우는 특정 자료 형태로 표현되는 각각의 칼럼들의 집합이다. 이 칼럼들의 순서가 각각의 로우에 일정하게 정해져있지만, SQL에서는 테이블의 칼럼을 다룰 때 그 순서가 뒤섞여도 전혀 상관 없다는 사실을 기억해 두어야한다. 이 점이 관계형 db의 중요한 개념이다.
테이블들은 db안에 있고, 이db들의 모음을 하나의 PostgreSQL 서버가 관리한다. 이 하나의 서버가 관리하는 데이터베이스 집합 단위를 클러스터라고한다.

## 새 테이블 만들기

새 테이블은 아래와 같이 테이블의 이름과 그 테이블을 구성하는 각 컬럼과 그 컬럼의 자료형을 지정해서 만든다.

```sql
CREATE TABLE weather (
    city            varchar(80),
    temp_lo         int,           -- low temperature
    temp_hi         int,           -- high temperature
    prcp            real,          -- precipitation
    date            date
);
```

psql안에서는 하나의 sql명령이 여러줄로 나뉘어져 있어도 되고, 한줄로 모두 표현되어도 상관없다. 하지만 하나의 명령은 반드시 하나의 세미콜론으로 끝난다.
sql문장을 작성할 때 공백문자(스페이스,탭, 줄바꿈문자)등은 자유롭게 사용할 수 있다. 즉 굳이 꼭 위와 같이 입력하지 않아도된다. 한줄로 길게 써도 된다. 단지 주의할 것은 "--"문자는 주석을 표현한 것인데 이것이 있으면 그다음부터 줄 끝까지 무시된다. SQL문법에서 예약어(keyword,명령이름, 구문 중간에 나오는 on,default,not null같은 것들)와 식별자(identifier,테이블이름, 칼럼이름 같은 것들)의 대소문자를 구별하지 않느낟. 단지, 식별자가 큰따옴표로 둘러 쌓여지면, 그 식별자는 입력한 그대로의 대소문자를 유지한다.
varchar(80)은 최대길이가 80글자인(byte가아니라 글자이다.)문자열을 저장할 수 있음을 나타내고, int는 정수형 숫자 real은 소숫점을 이용하는 숫자, date는 날짜형을 나타낸다. 칼럼 이름 date가 자료형 date와 같을 수 있다.
PostgreSQL에서는 사용자 정의 자료형을 만들수 있다. 따라서 표준 SQL과의 호환성을 유지하기 위해서 특별히 문법적으로 예약어 기능을 해야하는 것들을 제외한 자료형 이름은 문법적인 예약어가 아니다.

테이블을 삭제하거나 똑같은 이르므이 테이블을 다른 구조로 만드려면 다음과 같은 명령을 사용한다.

```sql
DROP TABLE 테이블이름:
```

## 테이블에 자료 입력하기

```sql
INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
```

각 칼럼의 실제 자료들은 그 테이블을 만들 때 지정한 자료형과 완벽하게 일치해야한다. 특히 숫자가 아닌 자료일 경우는 위 예제처럼 작은 따옴표로 둘러싼다. 날짜형(date)자료를 입력해야 할 경우는 그 값이 정확하게 날짜 표현이어야한다.
point 자료형은 다음과 같이 하나의 쌍으로 입력되어야한다.

```sql
INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
```

한편 각 칼럼의 입력 순서를 사용자가 다음과 같이 칼럼명을 미리 원하는 순서대로 지정하고 그 순서에 맞추어 입력할 수도있다.

```sql
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
```

이때는 굳이 테이블을 만들 때의 그 칼럼 순서와 같아야할 이유도 없으며, 특정 칼럼을 생략후 입력할 수도 있다.

데이터를 입력하는 또 다른 하나의 방법으로 COPY명령을 사용하는 방법이 있는데, 이것은 대용량 데이터를 빠르게 입력할 때 사용된다. 이 명령은 데이터베이스 백업/복구를 위해서 PostgreSQL전용으로 특별히 만들어진 명령이다. 그래서 자료를 한꺼번에 입력할 떄 아주 유용하다.

```sql
COPY weather FROM '/home/user/weather.txt';
```

이때 지정한 파일은 서버가 가동중인 호스트에 있어야 한다. 접속한 서버가 원격 호스트 경우라면 윗 파일을 원격 호스트에서 찾을 것이다.

## 테이블 자료 조회하기

입력한 자료를 찾아보려면, 테이블에 질의를 해야한다. 이것을 데이터베이스 용어로 쿼리라고한다. 이런 자료조회를 할때 사용할 구문은 SELECT이다. 이 구문은 크게 세 부분으로 구성된다.

1. 원하는 자료의 컬럼을 저장
2. 칼럼들이 있는 테이블들 -from절이라고하고 그다음은 원하는 부분을 지정하는 조건절 -where절이라고 한다.
3. where절이 생략되면 지정한 테이블의 모든 자료를 보여준다.

```sql
SELECT *FROM weather;
```

쿼리 문장은 WHERE절을 이용해서 검색 결과의 조건을 지정할 수 있다. WHERE절에 사용할 조건은 논리조건들의 집합으로 구성된다. 일반적으로 논리조건은 불리언 연산자를 이용해서, WHERE절 전체의 조건을 구성한다.

```sql
SELECT * FROM weather
    WHERE city = 'San Francisco' AND prcp > 0.0;
```

정렬 조건 추가가능

```sql
SELECT * FROM weather
    ORDER BY city;
```

중복제거

```sql
SELECT DISTINCT city
    FROM weather;

```

## table join

```sql
SELECT *
    FROM weather, cities
    WHERE city = name;
```

칼럼이름이 여러 테이블에 똑같이 있다면, 서버는 어떤 테이블에서 그 칼럼을 참조해야 하는지 몰라 오류를 낼 때가 있다. 그래서, 일반적으로 join구문을 작성할때 다음과 같이 칼럼 이름 앞에 테이블 이름을 함꼐지정해서 사용한다. 이것을 qualify(지정자)라고한다.

```sql
SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather, cities
    WHERE cities.name = weather.city;
```

## 집계함수

다른 대부분의 데이터베이스와 마찬가지로 PostgreSQL에서도 집계함수를 사용할 수 있다. 집계함수란 입력이 여러개의 로우이고, 출력이 하나인 결과인 것을 말한다. 테이블의 전체 로우수를 구하는 count, 평균 ,총합,최댓값,최솟값등등이 이런 함수이다.

```sql
SELECT max(temp_lo) FROM weather;
```

여기서 이 최고 기온의 해당 도시가 무엇인지 알기위해 다음과 같이 생각할 수 있다.

```sql
SELECT city FROM weather WHERE temp_lo = max(temp_lo);    -- 잘못된 구문
```

윗 쿼리는 오류를낸다. 왜냐하면, WHERE 절 다음에는 집계함수를 사용할수 없기 때문이다.(이렇게 되는 이유는 윗예를 들어서 max함수 자체가 select를 하지 않으면 나올 수 없는 값이기 때문이다.) 이런 문제는 다음과 같은 서브쿼리로 풀어야 원하는 결과를 낸다.

```sql
SELECT city FROM weather
    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
```

하나의 쿼리에서 서브쿼리가 있으면, 서버는 서브쿼리를 처리하고 , 그 결과를 서브쿼리가 있는 자리에 대치시키고 다시 쿼리를 한다.
집계함수는 일반적으로 GROUP BY절과 함께 사용하면 보다 다양하고 유용한 결과를 볼 수 있다.

```sql
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city;
```

위 결과 가운데, 또 집계된 자료에 대해서 어떤 조건이 주어질때 HAVING구문 사용

```sql
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING max(temp_lo) < 40;
```

집계 함수를 사용할 때에는 WHERE절과 HAVING절의 관꼐를 반드시 숙지하고 있어야한다. WHERE절은 조회할 집계되지 않은 자료에대한 조건이고, HAVING절은 집계된 자료에 대한 조건이다. 그래서WHERE절의 조건으로 HAVING절이 사용될 수 없다.

## 자료 갱신

이미 입력되어 있는 자료를 수정하려면 UPDATE명령을 사용한다.

```sql
UPDATE weather
    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
    WHERE date > '1994-11-28';
```

## 자료 삭제

테이블에서 필요없는 자료를 삭제하려면 DELETE명령을 사용한다.

```sql
DELETE FROM weather WHERE city = 'Hayward';
```

아래와 같은 구문을 실행할 때에는 항상 조심해야한다.

```sql
DELETE FROM tablename;
```

윗 쿼리는 삭제 작업에서 삭제대상을 지정하지 않았기 때문에 해당 테이블의 전체자료가 삭제 대상이 된다. 처리결과는 해당 테이블에는 아무런 자료도 없게된다. 이때, 그 지워야할 자료가 많다면 시간이 오래걸릴 것이고, 그동안 서버는 클라이언트에게 아무런 응답도 보내지 않는다.

## 뷰

복잡한 쿼리를 계속 반복하는 것은 번거로운 일이다. 이때 뷰를 만든다. 이것은 마치 또 하나의 새로운 테이블 처럼 사용할 수 있다.

```sql
CREATE VIEW myview AS
    SELECT city, temp_lo, temp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;

SELECT * FROM myview;
```

사용이 유연한 뷰를 만드는 것은 자료구조 설계의 핵심적인 요소이다. 일단 기본적인 뷰를 만들고 그것을 응용프로그램에서 사용한다면, 뷰가 참조하는 원래 테이블의 자료구조가, 만들어진 뷰에 영향을 미치지 않는 범위에서는 얼마든지 확장되고 수정될 수 있다. 이렇게 되면 응용프로그램 개발 부담을 줄여준다. 쿼리에서 실재 테이블을 지정하는 자리 어느곳이든 그 자리에 뷰를 사용할 수 있다. 또한 뷰를 가지고 또 다른 뷰를 만드는 것도 흔한 방법이다.

## 참조키

참조 무결성(referential integrity)
이것을 구현하기위해 단순하게 생각해서 weather테이블에 자료를 입력하기전에 먼저 cities테이블에 도시명이 있는지 살펴보고 있다면 입력작업을 계속 진행하고, 없다면 입력작업을 중지하도록 프로그램을 만들 수 있다. 처음에 아무런 참조 무결성 조건이 없는 상태보다는 좀 더 안전해졌지만, 아직도 많은 문제점들을 안고 있다. 이러한 문제를 PostgreSQL에서는 다음과 같이 간단히 참조키를 지정함으로써 해결가능하다.

```sql
CREATE TABLE cities (
        city     varchar(80) primary key,
        location point
);

CREATE TABLE weather (
        city      varchar(80) references cities(city),
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
);
```

참조키는 응용 프로그램에서 해야 할 일들을 대폭 줄여줌과 동시에 자료의 관계성을 보다 견고하게 만들어준다. 참조키 기능은 여기서 언급한 것보다 훨씬 많은 것을 제공한다.

## 트랜잭션

transcation 이란 모든 데이터베이스 시스템에서 기본적인 한 개념이다.
트랜잭션의 핵심은 여러개의 작업이 최종적으로는 하나로 취급된다는 것이다. 이것을 전부 적용 아니면 전부 취소 작업이라고 부른다. (all-or-nothing operation) 각각의 트랜잭션은 독립적이여서 동시에 발생한 트랜잭션에 대해서는 그 트랜잭션 안에서의 데이터에만 적용된다. 또 하나의 트랜잭션 안에서 어떤 작업 도중 오류가 발생 되었다면, 이전에 적용되었던 모든 작업들에 대해서는 모두 취소가 된다.
에를 들어서 간단한 은행 데이터베이스를 생각해보자. 이 은행 데이터 베이스에는 각 계좌의 현 잔액을 보관하는 accounts테이블과, 각 계좌의 거래내역을 보관하는 branches테이블로 구성되어있다. 이떄 현진이는 계좌에서 $100.00빼서 엄마의 계좌에 이체하려고 한다 이것을 구현한다면 다음과 같다.

```sql
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'hyunjin';
UPDATE branches SET balance = balance - 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'hyunjin');
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'mom';
UPDATE branches SET balance = balance + 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'mom');
```

물론 계좌 이체가 이렇게 간단하게 움직여지지는 않겠지만 여기서 중요한 것은 계좌 이체 작업을 하려면 적어도 네개의 독립된 update구문으로 작업해야 한다는 것이다. 이런 작업을 하는데, 만일 위의 네개의 작업 도중 부분적으로 작업을 성공하고, 그 나머지는 실패한다면, 각계좌에 남아있는 금액이 이상해진다. 이러한 사태를 막기위해서, 하나의 작업군(여러개의 작업)이 전부 처리가 되던지, 아니면 전부취소가 되는 이런 작업이 필요하다 이런 작업을 할때, 트랜잭션을 이용한다. 이런 하나의 트랜잭션 내에서 일군의 작업이 하나로 처리되는 것을 데이터베이스 용어로 트랜잭션의 원자성 atomic이라고 한다.
또한 트랜잭션 작업이 정상적으로 끝났을 경우에는 그 변경된 자료가 어떠한 간섭없이 저장되어야하고, 저장된 자료는 손상되지 않아야한다. 트랜잭션 기능을 제공하는 데이터베이스에서는 트랜잭션이 정상적으로 종료되었다고 알려주기 전에도 이미 하나의 트랜잭션에서 발생하는 모든 작업들을 영구저장장치(예, 하드디스크)에 기록을 해둔다. 이를 내구성 (durablility)라고 한다.
트랜잭션에서 중요한 또하나의 속성은 하나의 트랜잭션은 다른 트랜잭션에 의해서 간섭받지 않아야한다는 것이다. 즉 동시에 여러개의 트랜잭션이 발생했을 때, 각각의 트랜잭션은 다른 트랜잭션에서 변경되고 있는 자료들에 대해서는 참조하거나 간섭할 수 없다. 이것을 고립성(isolation)이라고한다. 예를 들어서 모든 계좌의 현잔액 합계를 구하는 트랜잭션이 작업중인데 현잔액을 바꾸는 다른 트랜잭션에 의해서 그 계좌의 현잔액이 바뀌게 된다면 정확한 그 시점의 현 잔액 합계를 구할 수 없다. 그래서 트랜잭션은 각각의 명령이 수행 될 때마다 그 변경사항이 데이터베이스의 원래 자료에 영향을 주는 것이 아니라, 트랜잭션 영역안에 있는 모든 작업이 끝났을 때, 한꺼번에 그 변경사항이 데이터베이스에 적용된다. 이때 부터 다른 트랜잭션이 그 변경된 데이터를 참조 할 수 있게 된다.이것을 정합성(consistency)라고 한다.
PostgreSQL에서 트랜잭션 작업을 하려면, 그 해당 작업 앞뒤로 BEGIN명령과 COMMIT명령을 지정한다. 다음과 같은 형태가 트랜잭션을 사용하는 예이다.

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
-- etc etc
COMMIT;
```

만약 작업도중 문제가 생겨서 다음 작업을 못하면 COMMIT작업 대신에 ROLLBACK명령을 사용해서 지금까지 작업한 내역을 모두 취소하고 트랜잭션을 종료한다.

PostgreSQL 에서는 모든 SQL구문은 모두 트랜잭션 안에서 실행되는 것으로 간주한다. BEGIN명령을 명시적으로 실행하지 않았다고 하더라도 실행하고자 하는 명령 앞뒤에, BEGIN,COMMIT명령을 함께 사용한다. 이때 BEGIN과 COMMIT사이의 영역을 트랜잭션 블록 이라고 한다.

몇몇 클라이언트 라이브러리는 자동으로 BEGIN,COMMIT 명령을 포함해서 실행하기 때문에, 사용자가 트랜잭션을 지정하면 오류를 내는경우도 있다.

트랜잭션 안에서 savepoint를 지정해서 작업을 좀 더 유연하게 처리할 수 있다. savepoint란 여기까지 작업이 정상 처리 되었다면, ROLLBACK TO명령을 이용해서 그 지점 전까지 작업한 것에 대해서는 작업한 내용을 보장하겠다는 표시하는 지점이다. 이 지점을 표시하는 방법은 SAVEPOINT명령을 이용하는 것이다.

savepoint로 취소 작업을 진행한 뒤에도 계속 트랜잭션 내 작업을 진행할 수 있다. 그렇게 작업을 하다가도 언제든지 해당 savepoint로 돌아갈 수 있다. 또한 더 이상 이 savepoint가 필요 없다고 판단되면 그것을 삭제해서 시스템 자원을 늘릴 수 있다. 하나 주의할 점은 특정 savepoint로 돌아갈 경우 그 지점 이후에 지정해 두었던 다른 savepoint들도 모두 취소되어 사라져 버린다는 점이다.
트랜잭션 내에서 일어나 모든 작업은 그 트랜잭션이 커밋되기 전까지는 다른 사용자들이 볼수 없다. 물론 해당 트랜잭션이 취소된다면 다른 사용자들은 절대로 그 변경했던 내용은 볼수없다.

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
-- 에구 ... Wally한테 가야하는 거였는데...
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Wally';
COMMIT;
```

## 윈도우 함수

윈도우 함수는 테이블에서 로우 집합을 대상으로 계산하는 함수다. 그 로우 집합은 한 로우에 대해서 어떠한 방식으로 관계된 로우들이다. 이 함수는 로우 집합 단위로 계산한다는 점에서 집계함수와 비슷하다. 집계함수는 해당 되는 로우 집합에 대해서 하나의 로우로 그 결과물을 보여주지만, 윈도우 함수는 각 로우 단위로 그 처리결과를 출력한다.

```sql
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
```

```code
  depname  | empno | salary |          avg
-----------+-------+--------+-----------------------
 develop   |    11 |   5200 | 5020.0000000000000000
 develop   |     7 |   4200 | 5020.0000000000000000
 develop   |     9 |   4500 | 5020.0000000000000000
 develop   |     8 |   6000 | 5020.0000000000000000
 develop   |    10 |   5200 | 5020.0000000000000000
 personnel |     5 |   3500 | 3700.0000000000000000
 personnel |     2 |   3900 | 3700.0000000000000000
 sales     |     3 |   4800 | 4866.6666666666666667
 sales     |     1 |   5000 | 4866.6666666666666667
 sales     |     4 |   4800 | 4866.6666666666666667
(10 rows)
```

네번째 칼럼에서 depname 칼럼 값을 기준으로 그룹화된 자료의 평균값을 각 로우마다 보여준다. 이 예제에서 보이는 avg함수는 집계함수와 그 사용법이 완벽하게 같은데, 뒤에오는 OVER절로 판단해서 윈도우 함수로 처리된다.

윈도우 함수 뒤에는 항상 OVER절을 사용한다. 이규칙은 이 함수가 윈도우 함수로 처리할 것인지, 그렇지 않을 것인지를 구분하는 문법상의 규칙이다. OVER절에는 윈도우 함수의 계산 대상이 되는 로우들을 집합화하는 방법을 정의한다. PARTITION BY로 정의하는 목록은 같은 그룹인지, 다른 그룹인지 구분하는 기준으로 사용되고, 같은 그룹내에서는 현재 로우 값도 포함해서 계산된 우니도우 함수의 결과값을 공유한다.
또한 OVER절로 집합화 하는 로우들의 정렬 순서를 ORDER BY절을 사용해서 지정 할 수 있다. 윈도우 함수의 계산 대상이 되는 로우는 FROM 다음부터WHERE, GROUP BY, HAVING절로 각 조건에 맞게 걸러진 가상테이블의 각 로우이다.
where조건절을 통해서 이미 걸러져 버린 로우에 대해서는 윈도우 함수의 계산 대상이 되지않는다. 하나의 쿼리에 여러개의 윈도우 함수를 사용할 수 있다. 이 함수들은 각각의 OVER절을 사용하여 각각 자료를 집합화 한다. 하지만 이 집합화 대상이 되는 가상 테이블은 같아야한다.
윈도우 함수와 관련된 또하나 중요한사항은 다음과 같다. 윈도우 프래임이라는 개념인데, 구분 대상이 되는 로우 집합들 가운데, 현재 윈도우 함수가 처리하는 로우 집합을 뜻한다. 많은 윈도우 함수들이 이 윈도우 프래임 단위로 계산을 한다. 초기값으로 ORDER BY절을 사용하면, 윈도우 프래임은 해당 정렬 방법으로 정렬해서 순차적으로 현재 로우 까지가 된다. ORDER BY 절이 빠지면, 그 부분되는 집합들의 모든 로우가 윈도우 함수의 계산 대상이된다.

## 상속

상속은 객체 지향 데이터베이스에서 사용하는 개념이다. 상속은 데이터베이스 설계 방법에 대한 새로운 가능성을 제시한다.
